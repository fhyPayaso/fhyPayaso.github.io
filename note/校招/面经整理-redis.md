

## 一、 Redis数据结构



## 二、 Redis缓存


**1. 工作方式: 旁路缓存**

需要修改代码，不能使用于闭源的系统中

+ 只读缓存
  + 查询操作 : 先查redis，命中直接返回，未命中查询数据库，并写入redis
  + 修改操作 : 直接在数据库中增删改，然后删除redis中的缓存，等下次读操作再重新缓存，需要保证原子性

+ 读写缓存

  读操作类似，增删改操作则直接操作redis，但此时数据库数据不是最新的，根据需求有同步直写和异步写回两种策略
  + 同步直写: 写请求发送给缓存同时，同时也发送给数据库，会降低性能
  + 异步写回: 当缓存即将被淘汰时再写回数据库

+ 保证一致性

    + 只读缓存中的写操作(单线程) : 删除缓存数据和删除数据库数据两个失败了一个。解决办法: 消息队列保存要删除的值，失败后用消息队列中的值重试
    + 只读缓存中的写操作(多线程) : 延迟双删策略, 先删缓存，再删db，延迟一段时间，再删一次缓存(延迟为了保证另一个线程旧数据写入完成)



**2. 缓存淘汰策略**

+ 针对设置了过期时间的数据

    ```
    volatile-lru : 最近最少使用淘汰
    volatile-lfu : 淘汰使用次数最少的
    volatile-random : 随机淘汰
    volatile-ttl : 离过期时间最近的淘汰
    ```    

+ 针对全部数据

    ```
    allkeys-lru : 最近最少使用淘汰
    allkeys-lfu : 淘汰使用次数最少的
    allkeys-random : 随机淘汰
    ```

+ 其他策略 : 

    ```
    no-eviction : 禁止淘汰, 溢出直接报错
    ```

**3. 缓存异常**


**(1) 缓存雪崩**

场景 : 大量数据请求无法被处理，直接访问数据库

+ 原因1 : 大量数据同时过期
  + 同一批数据设置随机的过期时间
  + 进行服务降级: 非核心请求返回默认值或空值，核心请求访问数据库

+ 原因2 : Redis实例宕机
  + 服务熔断: 防止引发连锁的数据库的雪崩，将缓存请求直接返回，不发送给redis
  + 服务限流: 仅允许少量请求通过，访问数据库

**(2) 缓存击穿**

场景: 某些热点key请求，无法命中redis，频繁请求数据库

解决办法: 热点key不设置过期时间

**(3) 缓存穿透**

场景: 某些key请求后，未命中redis，也未命中数据库，无法更新缓存

解决办法：

+ 发生缓存穿透之后，在redis中设置对key设置默认值或空值
+ 使用布隆过滤器判断数据是否存在，但是存在一定误差
+ 前端进行校验，过滤非法请求


## 三、 分布式Redis

### 1. Redis集群

为了保证一个节点宕机后服务还能正常使用，redis采用多个实例的集群方式, 但为了保证数据的一致性, 分为从库和主库, 从库只负责读,  主库负责读和写, 并将信息同步给从库
	
**(1) 主从库建立连接过程如下:** 
	
+ **一阶段同步**: 
    + 从库发起psync请求, 携带参数: runId = ?, offset = -1
    + 主库返回FULLRESYNC响应, 表示全量复制, 建立连接
+ **二阶段同步**：
    + 主库执行bgsave，生成RDB文件，发送给从库。复制过程中的写操作记录在内存的的replication buffer中
    + 从库收到RDB，清空当前数据库，从RDB完成数据加载 
+ **三阶段同步**
    + 主库将replication buffer中操作发送给从库，从库执行
+ **基于长连接的命令传播**
  + 主从库完成了全量复制后会⼀直维护⼀个⽹络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，可以避免频繁建⽴连接的开销。

**(2)主从级联模式**: 如果从库数量太多，则需要多次进行同步，导致主库负担较大，所以可以采用"主-从-从"的模式，
	
**(3)如何解决网络短闪**: 通过一个环形缓冲空间, 两个标志位, 分别记录主库和从库的位置, 网络断了, 主库新增操作继续向前进行, 恢复时将两个标志位中间的数据同步即可 (需要设置缓冲区大小避免出现覆盖情况)

**(4)如何解决主从数据不一致**: 主从复制是一种异步操作，存在延迟

+ 保证主从库之间网络状况良好
+ 根据主库和从库同步时使用的两个offset，如果相差大于阈值，则不从该从库中读数据

**(5)读取过期数据**: 

+ **定期删除**: 每隔一定时间，检查一部分数据是否过期， 但随机检查的数据量有限

+ **惰性删除**: 数据被访问到才检查是否过期，主库检查过期后可正常删除，但是从库不能执行删除操作，redis3.2之前会返回过期数据，时候会返回空值

+ **过期命令**: 主库设置过期命令后，需要一定延迟命令才能到达从库，所以过期命令最好选择时间点，而不是时间段

**(6) 脑裂**

**为什么脑裂会导致数据丢失**

+ 主库网络出现阻塞， 哨兵集群判断主库下线，开始选择新主库
+ 旧主库网络恢复，客户端发送新命令到旧主库
+ 新主库选择完后会将数据全量同步到旧主库中，导致切换期间的命令丢失

**如何解决脑裂数据丢失**

+ 通过配置保证: 主库连接的从库中⾄少有N个从库，和主库进⾏数据复制时的ACK消息延迟不能超过T秒，否则，主库就不会再接收客⼾端的请求了
+ 旧主库网络阻塞时，从库数据同步ACK消息延迟超过T秒，不满足条件，旧主库不能接受客户端数据
+ 旧主库网络恢复时，从库数量清零小于N，也不满足条件


	
### 2. 哨兵机制

**(1) 基本流程**

哨兵可以防止redis集群中主库挂掉时, 自动实现主从切换, 主要负责**监控、选主、通知**
	
+ **监控**: 哨兵向主库和从库定期发心跳包, 检查存活状态，规定时间未响应说明实例下线，一个哨兵的检查结果称为主观下线, 哨兵集群内部达成一致的检查结果称为客观下线

+ **选主**: 筛选 + 打分
  + 筛选掉网络状况不好的从库(断连次数过多)
  + 根据根据优先级、与主库同步程度、id序号打分
	
+ **通知**: 将选主结果通知给从库和客户端


**(2) 哨兵集群**

+ **哨兵集群建立** : 每个哨兵先和主库建立**发布订阅**关系, 从而知道彼此之间的地址

+ **哨兵连接从库**: 哨兵向主库发送info请求，主库将从库信息发给哨兵, 哨兵与从库建立发布订阅连接

+ **哨兵连接客户端**: 哨兵提供消息订阅频道, 供客户端订阅，用于向客户端更新新主库信息

+ **哨兵选主**: 哨兵集群内部通过raft选主