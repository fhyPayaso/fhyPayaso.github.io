
### 网络


+ OSI七层和TCP\IP四层
  + wifi属于OSI哪一层(物理和数据链路)
  + 有哪些应用层协议
  + dns发生在哪一层(应用层)
+ 三次挥手四次握手
  + 第三次握手是为啥，能不能改成两次
  + 四次挥手能不能改成三次
  + Timewait状态
  + closewait状态

+ Session和Cookie的区别，生命周期，Session什么时候失效
+ HTTPS
  + HTTP和HTTPS的区别
  + 解释一下对称非对称
  + HTTPS的加解密过程（非对称密钥加密和对称密钥加密）
  + Https的连接过程是什么
  + 如何解决中间人攻击

+ http
  + 协议的几种方法
  + get和post的区别
  + post和put的区别(put幂等)


+ 浏览器输入www.baidu.com 到显示页面经历了什么过程

+ TCP的拥塞处理机制
+ http3.0的QUICK

+ 状态码
+ TCP/IP报文信息
+ 发散问题
  + 向已经关闭的服务发送报文会怎样（超时重传，超过一定次数系统调用返回-1）
  + 向关机的服务器发送报文会怎样（ 😂一开始吓死我了，为啥会问这个）

+ HTTPS中数字证书如何校验；
+ DNS过程，DNS具体细节，如果找不到对应ip会怎样？
+ https的SSL建连过程会导致效率下降要怎么优化
+ https整个握手交互的过程总共花了多少rtt(可能是我面经看太少第一次看到求RTT的,还愣了一下RTT是什么)
+ https怎么保证证书可靠性(答了证书怎么验证) 面试官不满意,说我这个是在说有没有被篡改,但我想问的是,证书是一个证书链,权威机构给予子机构权限让他给服务器发证书,怎么保证说这个子机构是可靠的?或者换句话说怎么保证这个子机构发给服务器的时候,服务器怎么知道是权威机构授权的(没答上来)


+ 如果TIME_WAIT过多会造成什么影响
+ TDP、UDP的区别
+ HTTP底层可以用UDP实现吗？用UDP实现的话有什么好处？
+ HTTP有哪些状态码？
+ 2.osi七层模型
3.应用层和传输层的作用，协议有哪些
4.网络层协议
5.tcp为什么三次握手，状态机
6.tcp/udp区别，优缺点
7.浏览器从输入url到呈现结果整个过程
tcp和udp是哪一层的协议

tcp三次握手

如果第一次失败会发生什么？客户端和服务端是什么状态？

三次握手少一次可以吗？为什么？有什么危害？

为什么不能四次？

tcp是如何进行拥塞控制的

七层协议展开讲讲

tcp的报文格式是什么

http协议、协议格式、方法、get和post的区别

+ tcp 100m的数据发送出去底层流程
+ tcp 如何保证消息顺序
+ tcp长链接原理
+ ip、子网掩码、网关
---






### 操作系统

+ 进程并发和线程并发
+ 进程间有哪些通信方式？进程怎样共享内存？
+ 僵尸进程是怎么出现的？
+ 进程、线程、管程
+ LRU算法
+ 进程间通信方式
+ 进程间通信方式、Linux管道用什么来实现的
+ 虚拟内存、分页内存管理、多级分页、局部性原理
+ CPU的寻址过程
+ 进程和线程区别
+ 为什么进程切换开销比线程切换开销大？
+ 逻辑地址和物理地址
+ 虚拟内存有什么用？为什么要有虚拟内存？
+ CPU拿到地址后取得数据的过程？
+ CPU存储器类型
+ 缓存的作用介绍下
+ 逻辑地址包含哪些信息（不知道啥意思）
进程/线程间通信方式
12.管道
13.服务器端调用socket建立链接的整个过程，包括每个接口对应的系统调用以及底层实现

+ linux相关
  + Linux怎样查看后台进程？要筛选的话怎么做？怎样修改文件权限？怎样查看磁盘状态？





14.io模型
15.epoll_wait怎么调用的
16 .io多路复用、阻塞io和非阻塞io的区别
17.select和epoll
18.epoll是怎么通知用户态监听的文件描述符有新的事件到来的？底层怎么实现的？
19.水平触发和边缘触发
20.实际应用中如果用边缘触发，要怎么设计？


+ IO模型、epoll的底层 epoll那个函数线程不安全


top 命令，有个 load average，三个数字是什么意思？（不知道），cpu负载的百分数 是什么意思？（答错了）
进程和线程，线程通信方式
fd的默认上限是多少？（不知道）， io的本质（socket文件读写）
同步异步io，select和epoll


---


Https的 SSL/TLS加密过程


1. 得到公钥的一方
+ 产生对称秘钥
+ 对明文进行散列, 得到数字签名
+ 将 明文 + 数字签名 + CA证书 用对称秘钥加密
+ 将对称秘钥用公钥加密

2. 持有私钥的一方

+ 用私钥解密出对称秘钥
+ 用对称秘钥解密出 明文 + 数字签名 + CA证书
+ 验证CA证书身份
+ 对明文进行散列, 比较是否等于数字签名, 避免被篡改


