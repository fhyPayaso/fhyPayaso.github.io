## 编译器相关(GNU & GCC & Clang & MinGW)


### 1. GNU


先看看wiki百科上的官方说明：

> “GNU，名称来自Gnu's Not Unix"的缩写，一个类UNIX的操作系统，由GNU计划推动，目标在于创建一个完全兼容于UNIX的自由软件环境。”

由于当时UNIX系统是商业软件，是收费的，而且有一部分源码是没有开放的，所以在1983年，理查德·斯托曼提出GNU计划，希望发展出一套完整的开放源代码操作系统来取代Unix，计划中的操作系统，名为GNU。

因此，GNU的出现的目的就是为了取代UNIX系统。但是操作系统是包括很多软件的，除了操作系统内核之外，还要有编辑器，编译器，shell等等一些软件来支持。1989年，GNU项目中的其他部份，如编辑器、编译器、shell等都已经完成，独缺操作系统核心。1990年，自由软件基金会开始正式发展**Hurd**，作为GNU项目中的操作系统。

**注意：linux并不是GNU计划的一部分。linux只是使用了许多GNU计划软件(包括GCC编译器，文本编译器等)。**

1991年，Linux出现，所有GNU项目中，运行于用户空间的软件，都可以在Linux上使用。许多开发者转向于Linux，Linux成为常见的GNU计划软件运行平台。理查德·斯托曼主张，Linux操作系统使用了许多GNU计划软件，应正名为GNU/Linux，但没有得到Linux社区的一致认同，形成GNU/Linux命名争议。

1992年，Linux与其他GNU软件结合，完全自由的操作系统正式诞生。许多程序员参与了Linux的开发与修改，也经常将Linux当成开发GNU计划软件的平台。该操作系统往往被称为“GNU/Linux”或简称Linux。但Linux本身不属于GNU计划的一部份，GNU计划自己的内核Hurd依然在开发中，但直到2013年为止，都还没有稳定版本发布。
 
GNU工程十几年以来已经成为一个对软件开发主要的影响力量，创造了无数的重要的工具，例如：强健的编译器，有力的文本编辑器，甚至一个全功能的操作系统。这个工程是从1984年麻省理工学院的程序员理查德·斯托曼的想法得来的，他想要创建一个自由的、和UNIX类似的操作环境。从那时开始，许多程序员聚集起来开始开发一个自由的、高质量、易理解的软件。

GNU计划采用了部分当时已经可自由使用的软件，例如TeX排版系统和X Window视窗系统等。不过GNU计划也开发了大批其他的自由软件，这些软件也被移植到其他操作系统平台上，例如Microsoft Windows、BSD家族、Solaris及Mac OS。

许多UNIX系统上也安装了GNU软件，因为GNU软件的质量比之前UNIX的软件还要好。所以，GNU计划中的许多软件目前在所有的操作系统中都应用广泛(Unix，mac，linux，windows，bsd...)，最出名的就是GCC了
 
#### 总结 : 
       
> GNU计划本来是为了开发一个自由系统来取代UNIX的，但是由于开发的内核hurd一直不怎么样，这个系统至今都没出稳定版本，然而GNU计划中开发的其他一些自由软件，比如GCC编译器，却非常的好，在移植到各大操作系统上一直广泛使用至今。

> 注意一点：文中说的自由软件，千万别与免费软件混淆了，自由是说你可以自由的使用，当然前提是获得了源码才能自由的使用。
比如，你在一个应用里面使用了gcc计划的软件，你卖自己的应用多少钱你自己定。免费的软件不一定是开源的。
 

---


### 2. GCC

先看看wiki百科上的官方说明：

“ GCC（GNU Compiler Collection，GNU编译器套装），是一套由GNU开发的编程语言编译器。它是一套以GPL及LGPL许可证所发布的自由软件，也是GNU项目的关键部分，亦是自由的类Unix及苹果电脑Mac OS X 操作系统的标准编译器。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。

GCC原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC很快地扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，以及Go与其他语言。

原本用C开发，后来因为LLVM、Clang的崛起，令GCC更快将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序 ”

由于GCC已成为GNU系统的官方编译器（包括GNU/Linux家族），它也成为编译与创建其他操作系统的主要编译器，包括BSD家族、Mac OS X、NeXTSTEP与BeOS。

GCC通常是跨平台软件的编译器首选。有别于一般局限于特定系统与运行环境的编译器，GCC在所有平台上都使用同一个前端处理程序，产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。 
 
#### 总结：

> mac之前的cocoa框架便是用GCC编译的，所以ios与mac os都是默认使用的GCC编译器(现在是clang与llvm，下面会有介绍）android的系统层因为是linux内核，自然也是GCC编译的，但是android的app因为是运行在Dalvik虚拟机，所以用的不是GCC。windows的应用，大部分都是使用的vs系列的编译器，毕竟是windows自家的编译器，用到GCC的不多。


---


### 3. Clang & LLVM

#### Clang

先看看wiki百科上的官方说明: 

“ Clang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。它的目标是提供一个GNU编译器套装（GCC）的替代品。 Clang项目包括Clang前端和Clang静态分析器等。

这个软件项目在2005年由苹果电脑发起，是LLVM编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。Clang支持C、C++、Objective C。

Clang本身性能优异，其生成的AST所耗用掉的内存仅仅是GCC的20%左右。FreeBSD 10将Clang/LLVM作为默认编译器.测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。 
 
#### 总结：

> GCC目前作为跨平台编译器来说它的兼容性无异是最强的，兼容最强肯定是以牺牲一定的性能为基础的，苹果为了提高性能，因此专门针对mac系统开发了专用的编译器clang与llvm，clang用于编译器前段，llvm用于后端。


#### LLVM

先看看wiki百科上的官方说明：

“ LLVM，它是一个编译器的基础建设，以C++写成。它是为了任意一种编程语言写成的程序，利用虚拟技术，创造出编译时期，链接时期，运行时期以及“闲置时期”的优化。
 
在Xcode4之后，苹果将Xcode的默认编译器变成了LLVM，为什么呢？

**LLVM历史**

Apple（包括中后期的NeXT） 一直使用GCC作为官方的编译器。GCC作为开源世界的编译器标准一直做得不错，但Apple对编译工具会提出更高的要求。

一方面，是Apple对Objective-C语言（甚至后来对C语言）新增很多特性，但GCC开发者并不买Apple的帐 —— 不给实现，因此索性后来两者分成两条分支分别开发，这也造成Apple的编译器版本远落后于GCC的官方版本。另一方面，GCC的代码耦合度太高，不好独立，而且越是后期的版本，代码质量越差，但Apple想做的很多功能（比如更好的IDE支持）需要模块化的方式来调用GCC，但GCC一直不给做，从根本上限制了LLVM-GCC的开发。 所以，这种不和让Apple一直在寻找一个高效的、模块化的、协议更放松的开源替代品，于是Apple请来了编译器高材生Chris Lattner， LLVM就这样产生了。
 
**Clang历史**

Apple吸收Chris Lattner的目的要比改进GCC代码优化宏大得多——GCC系统庞大而笨重，而Apple大量使用的Objective-C在GCC中优先级很低。此外GCC作为一个纯粹的编译系统，与IDE配合得很差。加之许可证方面的要求，Apple无法使用LLVM 继续改进GCC的代码质量。于是，Apple决定从零开始写 C、C++、Objective-C语言的前端 Clang，完全替代掉GCC。

正像名字所写的那样，Clang只支持C，C++和Objective-C三种C家族语言。2007年开始开发，C编译器最早完成，而由于Objective-C相对简单，只是C语言的一个简单扩展，很多情况下甚至可以等价地改写为C语言对Objective-C运行库的函数调用，因此在2009年时，已经完全可以用于生产环境。C++的支持也热火朝天地进行着。  
 
#### 总结：

> 因为GCC的编译器已经慢慢无法满足苹果的需求，因此，苹果开发了Clang与LLVM来完全取代GCC，Xcode4之后，苹果的默认编译器已经是LLVM了。Clang作为编译器前端，LLVM作为编译器后端。



![](https://img-blog.csdnimg.cn/20190319102057397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMxODcwNTc=,size_16,color_FFFFFF,t_70)

---

### 4. MinGW

MinGW 的全称是：Minimalist GNU on Windows 。

它实际上是将经典的开源 C语言 编译器 **GCC** 移植到了 Windows 平台下，并且包含了 Win32API 和 MSYS，因此可以将源代码编译生成 Windows 下的可执行程序，又能如同在 Linux 平台下时，使用一些 Windows 不具备的开发工具。

一句话来概括：**MinGW 就是 GCC 的 Windows 版本** 。 有以下几个特点: 

+ MinGW 是开源软件，可以免费使用。
+ MinGW 由一个活跃的开源社区在持续维护，因此不会过时。
+ MinGW 支持最新的 C语言 标准。
+ MinGW 使用 Windows 的C语言运行库，因此编译出的程序不需要第三方 DLL ，可以直接在 Windows 下运行。
 

---

### 5. 编译器相关

##### 苹果以clang作为编译器前端，llvm作为编译器后端，那么编译器的前后端到底是什么东西呢？

     我们先回到一个常识性的问题，什么是编译器呢？简单地说，编译器可以看作是一个语言翻译器。就像把中文翻译成英语一样，编译器可以把高级语言翻译成计算机能够执行的机器语言。

学过编译原理这门课程的同学对编译流程应该很熟悉。编译原理中的前端和后端:

+ **前端** : `高级语言 -> 词法分析 -> 语法分析 -> 语义分析 -> 中间代码生成 -> 中间语言`

+ **后端** : `中间语言 ->  中间代码优化 -> 代码生成 -> 目标代码优化 -> 目标语言`

以GCC编译器为例，GCC作为经典的编译器，自然也是遵循这个教科书流程（实际GCC的处理更复杂点，但本质上是一样的）。试想一下，是否可以为不同的高级语言单独写一个前端，然后为不同的处理器架构单独写一个后端呢？

GCC基本上也是这么实现的，不过不要误会，并没有一个统一的gcc执行程序能够处理如此多的前端和后端，每个语言的编译器都是一个独立的程序（如C语言的编译器是gcc，C++的编译器是g++），而不同的后端也要对应不同的可执行程序。你可以下载单独的一份GCC源代码，通过不同的configure来生成自己需要的编译器。

GCC强大的真正原因是什么？是因为它支持了众多的前端和后端吗？这些都不过是一个表象而已。GCC是一款真正自由的编译器，我们可以随时把代码拿过来修改以实现自己需要的功能。如果你的硬件平台增加了一些指令，而普通的编译器并不能产生这些指令怎么办？在GCC后端添加这些指令吧。如果你觉得C语言用的不太顺手，想给它添加一些功能怎么办？修改GCC的前端吧。因为有了GCC，我们才拥有这些自由，以及迅速实现自己想法的能力，而这些才是GCC强大背后的基础。




### 6. gcc和g++的主要区别

1. 对于 *.c和*.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）

2. 对于 *.c和*.cpp文件，g++则统一当做cpp文件编译

3. 使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL

4. gcc在编译C文件时，可使用的预定义宏是比较少的

5. gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：

	```
	#define __GXX_WEAK__ 1
	#define __cplusplus 1
	#define __DEPRECATED 1
	#define __GNUG__ 4
	#define __EXCEPTIONS 1
	#define __private_extern__ extern
	```



### 7. 几个误区

+ **gcc只能编译c代码,g++只能编译c++代码**

	两者都可以，但是请注意：

	+ 后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。
	
	+ 编译阶段，g++会调用gcc。对于c++代码，可以用gcc或g++来编译，二者等价的。
	
	+ 链接阶段，因为gcc命令不能自动和C++程序使用的库联接，所以通常用g++来完成链接。一般为了方便，干脆编译和链接都用g++了。这就给人一种错觉，好像cpp程序只能用g++编译链接似的。


+ **gcc不会定义__cplusplus宏，而g++会**

	实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。 

+ **编译只能用gcc，链接只能用g++**

	严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C++程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。







**参考文章:**


+ https://blog.csdn.net/u013187057/article/details/85222007

+ https://blog.csdn.net/itianyi/article/details/43057279

+ https://www.cnblogs.com/ggg-327931457/p/9694401.html







