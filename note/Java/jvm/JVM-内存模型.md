
### Java基础之-JVM-内存模型

> ps : 从前面试的时候复习这块比较仓促，从做学问的角度来说自己的理解程度还差得远，所以Jvm这块重新梳理一下，以解惑为主，


+ 什么是内存模型

    从一开始就在不断说Java的内存模型，那我们先不谈Java，先从计算机的角度来理解一下内存模型是个什么东西

    CPU在运算的时候,除了寄存器中的数据,其他数据都是存放在主存(计算机物理内存)当中的，而CPU的运算速度很快，远远超过了主存的读写速度，
主存和硬盘之间同样存在这个问题，这时候就要提到组成原理讲过的**CPU-Cache-主存， 主存-Cache-硬盘**模型，这里只说前者。

    Cache，即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。Cache中保存着CPU刚用过或循环使用的一部分数据，CPU进行计算时直接从它
的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。当然为了更高效，后面发展出了多级缓存 : 一级缓存（L1），二级缓存（L2）甚至三级缓存，这时候工作顺序变成了CPU先从L1取数据，如果没有就从L2取，如果还没有就从L3或者主存中取
 





Java内存模型-JMM(Java Memory Model)

Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： 

+ 程序计数器 
+ Java虚拟机栈 
+ 本地方法栈 
+ 堆 
+ 方法区

![](http://img.hellofhy.cn/18-5-1/10538549.jpg)



#### 1. 程序计数器(Program Counter Register)

+ 概念 : 程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。 但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。  

+ 作用 : 

	+ 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

	+ 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 

+ 特点 : 

	+ 是一块较小的存储空间
	+ 线程私有。每条线程都有一个程序计数器。
	+ 是唯一一个不会出现OutOfMemoryError的内存区域。
	+ 生命周期随着线程的。创建而创建，随着线程的结束而死亡。 



#### 2. Java虚拟机栈(JVM Stack)

Java虚拟机栈是描述Java方法运行过程的内存模型。与程序计数器一样，Java虚拟机栈也是线程私有的，用通俗的话将它就是我们常常听说到堆栈中的那个“栈内存”。

Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做**“栈帧”**的区域，每一个方法从调用至出栈的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程。这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：
	
+ 局部变量表（局部变量表需要的内存在编译期间就确定了所以在方法运行期间不会改变大小）
+ 操作数栈
+ 动态链接
+ 方法出口等

> 注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。 
这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。 

#### 3、本地方法栈 

本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间。

#### 4、堆

+ 作用 : 堆是用来存放对象的内存空间。 几乎所有的对象都存储在堆中。 
 
+ 特点 : 

	+ 线程共享 

		整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的。

	+ 在虚拟机启动时创建

	+ 垃圾回收的主要场所。

	+ 可以进一步细分为：新生代、老年代。 
	
		新生代又可被分为：Eden、From Survior、To Survior。 
不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。
	
	+ 堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。 



#### 5、方法区

+ 概念 : Java虚拟机规范中定义方法区是堆的一个逻辑部分。 
方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。


+ 特点 : 方法区的特点

	+ 线程共享 
	
		方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
	+ 永久代 
	
		方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。

	+ 内存回收效率低 

		方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。
	
	+ Java虚拟机规范对方法区的要求比较宽松。 
		
		和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 




### 总结

+ Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。 
两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 
只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。

+ Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。

+ 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。

+ 程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。 
而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。






 
 [JVM基础概念总结：数据类型、堆与栈](http://developer.51cto.com/art/200911/165015.htm)
 
 [JVM内存模型详解](https://blog.csdn.net/genius_ge/article/details/76151179)


---

[计算机内存模型概念](https://blog.csdn.net/vtopqx/article/details/78364685)
[Java内存模型是什么](https://blog.csdn.net/gupao123456/article/details/81221641)