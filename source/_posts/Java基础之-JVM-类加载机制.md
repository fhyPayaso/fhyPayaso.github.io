---
title: Java基础之-JVM-类加载机制
date: 2018-05-01
tags: Java
---

##Java基础之-JVM-类加载机制


概念: 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是Java的类加载机制。

在Java语言中，类的加载，连接和初始化过程都是在程序运行期间完成的(动态性)，这样虽然会增加类的加载性能开销，但是这也为java应用程序提供高度的灵活性。


#### 1、类加载过程

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了：**加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)**七个阶段，其中验证、准备、解析三个部分统称链接。
![](http://img.hellofhy.cn/18-5-1/89563219.jpg)


##### 加载阶段

+ **(1)加载 : 查找并加载类的二进制数据**

	加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
	+ 通过一个类的全类名来获取定义此类的二进制字节流
	+ 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

	> 相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。

	> 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在java堆中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。



##### 链接阶段

加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段还未结束，连接阶段可能已经开始，这部分夹杂在加载阶段进行的动作，依然属于连接阶段的内容，并且加载阶段必定早于连接阶段开始

+ **(2)验证 : 确保被加载的类的正确性** 

	+ **文件格式验证** : 第一阶段要验证字节流是否符合Class文件格式的规范，例如：
		
		+ 是否以魔数0xCAFEBABE开头
		+ 主次版本号是否在当前虚拟机的处理范围之内
		+ 常量池中的常量是否有不被支持的类型

	+ **元数据验证**: 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范的要求，例如:

		+ 一个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）
		+ 这个类的父类是否继承了不允许被继承的类
		+ 如果这个类不是抽象类，是否实现了其父类或者接口要求实现的所有的方法
		+ 类中的字段，方法是否与父类产生矛盾

	+ **字节码验证**: 第三阶段主要目的是通过数据流和控制流分析，确定程序语法是否是合法的，符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时候不会做出对虚拟机有危害的事情。例如:

		+ 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型则是危险的
		+ 保证跳转指令不会跳转到方法体以外的字节码指令上
		+ 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这种情况：在操作栈中放置一个int类型数据，使用却将他按照long类型使用
	
	+ **符号引用验证**: 第四阶段的校验确保解析动作能正确执行,发生在虚拟机将符号引用转化为直接引用的时候，这个转换动作发生在连接的第三阶段--解析中发生，符号引用可以看做是对类自身以外的信息进行匹配性校验，例如:
		+ 符号引用中通过字符串描述的全限定名是否能找到对应的类
		+ 在指定的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
		+ 符号引用中的类，字段，方法的访问性是否可以被当前类访问。

		
+ **(3)准备：为类的静态变量分配内存，并将其初始化为默认值**

	准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
	
	+ 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
	+ 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

		假设一个类变量的定义为：`public static int value = 3`

		那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
		
		![](http://p0y1qzu73.bkt.clouddn.com/18-5-1/90110776.jpg)

	+ 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

		假设上面的类变量value被定义为： `public static final int value = 3`
	
		编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。
		
+ **(4)解析 : 把类中的符号引用转换为直接引用** 

	+ **符号引用** : 符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。

	+ **直接引用** : 直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

	解析的动作主要针对四类符号引用进行。分别对应编译后常量池内的四种常量类型。

	+ 类、接口的解析(CONSTANT_Class_Info)
	+ 字段解析(CONSTANT_Fieldref_Info)
	+ 类方法解析(CONSTANT_Methodef_Info)
	+ 接口方法解析(CONSTANT_InterfaceMethoder_Info)
	
	
	
##### 初始化阶段

+ **(5)初始化:** 

	类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。
	
	+ `<clinit>()`方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生的，他按照代码中出现的顺序收集，静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的，在静态语句块中只能赋值不能访问,例如:

			public class Test {
			    static{
			        i = 1;//可以赋值
			        System.out.println(i);//不能访问
			    }
			    static int i = 0;
			}

	+ `<clinit>()`方法在执行之前必须保证自己父类的类构造器方法已经执行完毕,因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object

	+ `<clinit>()`并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。

	+ 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成`<clinit>()`方法，但是接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父类接口的`<clinit>()`方法，只有父类接口中定义的变量使用时父类接口才会初始化，另外接口实现类在初始化时也一样不会执行接口的`<clinit>()`方法。

	+ 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确的加锁，同步。

#### 2、类加载器


概念 : JVM设计者把类加载阶段中的“通过'类全名'来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

##### (1)类与类加载器

对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。


##### (2)双亲委派模型

> 从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：


+ **启动类加载器（Bootstrap ClassLoader）**：负责加载`JAVA_HOME\lib`目录中的、并且能被虚拟机识别的类库到JVM内存中(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）,如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。

+ **扩展类加载器（Extension ClassLoader）**：该加载器主要是负责加载`JAVA_HOME\lib\`，该加载器可以被开发者直接使用。

+ **应用程序类加载器（Application ClassLoader）**：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。


我们的应用程序都是由这三类加载器互相配合进行加载的，我们也可以加入自己定义的类加载器。这些类加载器之间的关系如下图所示：

![](http://img.hellofhy.cn/18-5-1/12560359.jpg)

如上图所示的类加载器之间的这种层次关系，就称为类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。


> 双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。在ClassLoader源码里也可以看出：


	public abstract class ClassLoader {
	    
	    protected Class<?> loadClass(String name, boolean resolve)
	        throws ClassNotFoundException
	    {
	            //首先，检查该类是否已经被加载
	            Class c = findLoadedClass(name);
	            if (c == null) {
	                long t0 = System.nanoTime();
	                try {
	                    //先调用父类加载器去加载
	                    if (parent != null) {
	                        c = parent.loadClass(name, false);
	                    } else {
	                        c = findBootstrapClassOrNull(name);
	                    }
	                } catch (ClassNotFoundException e) {
	                    // ClassNotFoundException thrown if class not found
	                    // from the non-null parent class loader
	                }
	
	                if (c == null) {
	                    //如果父类加载器没有加载到该类，则自己去执行加载
	                    long t1 = System.nanoTime();
	                    c = findClass(name);
	
	                    // this is the defining class loader; record the stats
	                }
	            }
	            return c;
	    }
	}
	
通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。
	
> 使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。















参考博客 : 

[JVM（三）：类加载机制（类加载过程和类加载器）](https://blog.csdn.net/boyupeng/article/details/47951037)

[java类的加载机制](https://www.cnblogs.com/ityouknow/p/5603287.html)