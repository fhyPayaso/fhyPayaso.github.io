<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="fhyPayaso&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="fhyPayaso&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="fhyPayaso">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>fhyPayaso's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fhyPayaso's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/29/%E9%9A%8F%E7%AC%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/%E9%9A%8F%E7%AC%94/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-29 16:29:27" itemprop="dateCreated datePublished" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/01/07/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90-fork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/07/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90-fork/" class="post-title-link" itemprop="url">linux内核分析——fork()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-07T00:00:00+08:00">2019-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="linux内核分析——fork"><a href="#linux内核分析——fork" class="headerlink" title="linux内核分析——fork()"></a>linux内核分析——fork()</h2><blockquote>
<p>分析版本 linux-4.18</p>
</blockquote>
<h3 id="一、c-层面的fork-与vfork"><a href="#一、c-层面的fork-与vfork" class="headerlink" title="一、c++层面的fork()与vfork()"></a>一、c++层面的fork()与vfork()</h3><p>在Unix环境下编写c/c++程序，可以通过引入<code>#include&lt;unistd.h&gt;</code>头文件来使用其中的<code>fork()</code>和<code>vfork()</code>函数,以课设题目中要求的程序举例,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    string input, output;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    &#x2F;&#x2F; pid &#x3D; vfork();</span><br><span class="line"></span><br><span class="line">    if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;error fork&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 在子进程中进行转换操作</span><br><span class="line">        output &#x3D; change(input);</span><br><span class="line">        &#x2F;&#x2F; cout &lt;&lt; &quot;child  ,id : &quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 在父进程中进行输出操作</span><br><span class="line">        cout&lt;&lt;&quot; 输出结果为 : &quot;&lt;&lt;output&lt;&lt;endl;</span><br><span class="line">        &#x2F;&#x2F; cout &lt;&lt; &quot;father ,id : &quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>change()</code>函数功能为将输入的字符串进行大小写变换，具体实现如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string change(string str)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (str[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;Z&#39;)</span><br><span class="line">            str[i] +&#x3D; 32;</span><br><span class="line">        else if (str[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;z&#39;)</span><br><span class="line">            str[i] -&#x3D; 32;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面分别调用fork和vfork两个函数，观察结果</p>
<ul>
<li><p>fork()</p>
  <img src="http://img.hellofhy.cn/19-1-7/99468250.jpg" width="60%" height="50%" />

<p>  可以看到转换函数并未产生作用</p>
</li>
<li><p>vfork()</p>
  <img src="http://img.hellofhy.cn/19-1-7/38451921.jpg" width="60%" height="50%" />

<p>  输入的字符串转换成功</p>
</li>
</ul>
<p>通过查阅资料，简单总结一下<code>fork</code>和<code>vfork</code>异同</p>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li><p>两者的返回值代表的含义相同，当进程复制完成后，会将当前进程刚复制好的子进程的pid返回，而子进程没有自己的子进程，所以返回0，即:</p>
<ul>
<li>返回值-1 : 复制进程出错</li>
<li>返回值0 : 当前为子线程</li>
<li>返回值大于0 : 当前为父亲线程</li>
</ul>
</li>
<li><p>无论是fork还是vfork，在执行完后，都会变成两个进程，下面的代码会被执行两次，每个进程各执行一次</p>
</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul>
<li><p>内存空间的使用</p>
<ul>
<li>fork操作产生的子进程是将父亲进程的数据段、代码段拷贝一份，之后执行代码两者相互不影响</li>
<li>而vfork操作的子进程和父进程共用一块数据段、栈和堆</li>
</ul>
</li>
<li><p>执行顺序</p>
<ul>
<li>fork操作之后的两个进程执行顺序随机，由调度器决定</li>
<li>vfork保证子进程先运行，在调用exec 或exit 之后父进程才可能被调度运行。如果在<br>调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</li>
</ul>
</li>
</ul>
<p>所以对于刚才的两次结果来说，fork之后两个进程空间不影响，子进程的操作不会导致父进程变量的改变，而vfork则可以做到; </p>
<p>另外在调用vfork时，程序结束的标志并不能使用<code>return0</code>,而要用<code>exit(0)</code>，因为vfork子进程必然先执行，return操作会破坏函数栈，且函数栈与父进程共用，子进程完毕后父进程再想执行就会因为函数栈缺失发生段错误，所以一定要直接<code>exit(0)</code></p>
<h3 id="二、glibc与系统调用"><a href="#二、glibc与系统调用" class="headerlink" title="二、glibc与系统调用"></a>二、glibc与系统调用</h3><h4 id="1、glibc与libc的区别"><a href="#1、glibc与libc的区别" class="headerlink" title="1、glibc与libc的区别"></a>1、glibc与libc的区别</h4><p>glibc 和 libc 都是 Linux 下的 C 函数库，不过</p>
<ul>
<li>libc 是 Linux 下的 ANSI C 函数库</li>
<li>glibc 是 Linux 下的 GUN C 函数库</li>
</ul>
<p>那么ANSI C和GUN C有什么区别呢</p>
<ul>
<li><p>ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15 个部分，包括<code>&lt;math.h&gt;,&lt;stdio.h&gt;</code>…等</p>
</li>
<li><p>GNU C 函数库类似于第三方插件。Linux 的一些操作是用 C 语言实现的，因此，GUN 组织开发了一个 C 语言的库 以便让我们更好的利用 C 语言开发基于 Linux 操作系统的程序。</p>
</li>
</ul>
<p>不过现在的不同的 Linux 的发行版本对这两个函数库有不同的处理方法，有的可能统一集成在glibc里了，例如ubuntu。 </p>
<p>所以说，我们编写程序时所调用的fork()函数，是在libc/glibc中实现的，而对于fork这种系统调用，glibc并没有实际的操作，只是调用了操作系统所提供的<strong>系统调用</strong>接口。</p>
<h3 id="2、系统调用"><a href="#2、系统调用" class="headerlink" title="2、系统调用"></a>2、系统调用</h3><p>提到系统调用，先回顾下操作系统<strong>内核态</strong>和<strong>用户态</strong>的概念 :</p>
<ul>
<li><p><strong>用户态</strong> : 当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为Ring3，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；</p>
</li>
<li><p><strong>内核态</strong> : 当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。</p>
</li>
</ul>
<p>用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。</p>
<p>这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。</p>
<p>我们所研究的fork便是一种系统调用，调用时会发生从用户态到内核态的切换，去执行内核部分的代码，所以fork的真正实现在linux内核代码中才可以看到</p>
<h3 id="三、内核代码分析"><a href="#三、内核代码分析" class="headerlink" title="三、内核代码分析"></a>三、内核代码分析</h3><h4 id="1、-fork与vfork的系统调用"><a href="#1、-fork与vfork的系统调用" class="headerlink" title="1、 fork与vfork的系统调用"></a>1、 fork与vfork的系统调用</h4><p>首先我们先看下fork和vfork的系统调用定义中具体操作，这里研究的是4.18版本的Linux内核:</p>
<ul>
<li><p><strong>sys_fork</strong></p>
  <img src="http://img.hellofhy.cn/19-1-7/46125080.jpg" width="60%" height="50%" />

<p>  sys_fork中先检查了MMU的配置，如果支持nommu模式直接调用_do_fork方法，否则返回错误。</p>
<p>  这里的MMU是指存<strong>储器管理单元</strong>(<em>Memory Management Unit</em>),具有内存映射功能，而内存映射的行为会影响到<code>fork(),vfork(),clone()和ptrace()</code>的工作方式。</p>
</li>
<li><p><strong>sys_vfork</strong></p>
  <img src="http://img.hellofhy.cn/19-1-7/7147810.jpg" width="60%" height="50%" />

<p>  sys_vfork则是直接调用_do_fork方法，不过第一个参数为几个标志的或运算结果</p>
</li>
</ul>
<p>所以无论是fork还是vfork，真正的操作都是在 <code>_do_fork()</code>函数中完成的，这时的函数调用情况为</p>
<img src="http://img.hellofhy.cn/19-1-7/18245292.jpg" width="70%" height="70%" />



<h4 id="2、-do-fork-源码分析"><a href="#2、-do-fork-源码分析" class="headerlink" title="2、 _do_fork()源码分析"></a>2、 _do_fork()源码分析</h4><h5 id="1-参数分析"><a href="#1-参数分析" class="headerlink" title="(1) 参数分析"></a>(1) 参数分析</h5><img src="http://img.hellofhy.cn/19-1-7/16527447.jpg" width="40%" height="40%" />


<ul>
<li><p><strong>clone_flags</strong> : 用来控制进程复制过的一些属性信息, 描述你需要从父进程继承那些资源。该标志位的4个字节分为两部分。最低的一个字节为子进程结束时发送给父进程的信号代码，通常为SIGCHLD；剩余的三个字节则是各种clone标志的组合（本文所涉及的标志含义详见下表），也就是若干个标志之间的或运算。通过clone标志可以有选择的对父进程的资源进行复制</p>
</li>
<li><p><strong>stack_start</strong> : 子进程用户态堆栈的地址 </p>
</li>
<li><p><strong>stack_size</strong> : 用户状态下栈的大小, 该参数通常是不必要的, 总被设置为0 </p>
</li>
<li><p><strong>parent_tidptr</strong> : 父进程在用户态下pid的地址，该参数在CLONE_PARENT_SETTID标志被设定时有意义 </p>
</li>
<li><p><strong>child_tidptr</strong> : 子进程在用户太下pid的地址，该参数在CLONE_CHILD_SETTID标志被设定时有意义 </p>
</li>
<li><p><strong>tls</strong> : linux2.5.32以后, 添加了<strong>TLS</strong>(<em>Thread Local Storage</em>)机制, 该参数代替了老版本的regs </p>
</li>
</ul>
<p>其中<code>clone_flags</code>的含义如下表所示:</p>
<img src="http://img.hellofhy.cn/19-1-9/58914826.jpg" width="80%" />


<h5 id="2-内容分析"><a href="#2-内容分析" class="headerlink" title="(2)内容分析"></a>(2)内容分析</h5><img src="http://img.hellofhy.cn/19-1-7/55599425.jpg" width="60%" />

<ul>
<li><p>文档注释里所说的ptrace是一个系统调用函数，提供了一个进程（the “tracer”）监察和控制另一个进程（the “tracee”）的方法。所以这段代码即为根据参数所传入的<strong>clone_flags</strong>参数来决定子进程是否需要被监听和控制，如果需要则根据<strong>clone_flags</strong>来确定监听事件的类型，分为: <code>vfork、clone、fork</code>三种,最后检查该种事件是否允许被监听，如果不允许，则监听事件标志置零。</p>
</li>
<li><p>紧接着调用<code>copy_process</code>方法进行真正的进程拷贝操作，返回值赋给局部变量<code>struct task_struct *p;</code>，这个<code>task_struct</code>类型即为进程的核心部分PCB。  </p>
</li>
<li><p><code>add_latent_entropy()</code>函数依赖于<code>add_device_randomness()</code>,作用为向输入池中添加特殊的设备/启动数据，以此来帮助完成初始化操作。</p>
</li>
<li><p>最后检查刚复制好的进程PCB是否有错误，如有错误，直接返回错误信息</p>
</li>
</ul>
<img src="http://img.hellofhy.cn/19-1-7/83888141.jpg" width="60%" />

<ul>
<li><p><code>trace_sched_process_fork()</code>需要在线程激活之前进行，如果线程退出过快，下面代码的线程指针可能会无效</p>
</li>
<li><p>紧接着从PCB结构体中获取子进程的pid，再通过<code>pid_vnr</code>获取当前命名空间下的局部pid，赋值给局部变量nr</p>
</li>
<li><p>如果需要对父进程的pid设置，则通过<code>put_user()</code>,将子进程的局部pid与父进程的pid相关联</p>
</li>
<li><p>如果调用类型为vfork，则将子进程的标志位<code>vfork_done</code>作为参数，进行vfork的初始化.</p>
<p>  <code>init_completion()</code>会将done字段初始化为0，wait字段的自旋锁为未锁，等待队列为空。这说明调用该完成量的进程必须等待某事件完成(即另外一进程必须先调用completiom()唤醒该完成量)。 </p>
<p>  <code>get_task_struct()</code>作用为增加进程的引用计数</p>
</li>
</ul>
<img src="http://img.hellofhy.cn/19-1-7/14226258.jpg" width="60%" />

<ul>
<li><p><code>wake_up_new_task()</code>将子进程加入运行队列，唤醒子进程，分配CPU时间片，此时子进程开始真正执行</p>
</li>
<li><p>如果开始的监听事件有效，则调用<code>ptrace_event_pid</code>方法，开始监听与控制</p>
</li>
<li><p>这时子进程已经开始执行，所以在vfork的调用类型下， 通过<code>wait_for_vfork_done()</code>方法来判断父进程是否可以执行，正好与之前的<code>init_completion()</code>操作相对应，若vfork已经执行完成，则通知ptrace，父进程开始执行</p>
</li>
<li><p><code>put_pid()</code> 判断当前的pid-&gt;count是否等于1，如果等于1的话，再减去1的话，就是0.<br>说明后面没有人用这个pid了，因此要把ns中对pid的缓存去掉，并通过put_pid_ns将ns的ns-&gt;kref 一次减1</p>
</li>
<li><p>最后返回子进程在当前命名空间下的pid</p>
</li>
</ul>
<h4 id="2、-copy-process-源码分析"><a href="#2、-copy-process-源码分析" class="headerlink" title="2、 copy_process()源码分析"></a>2、 copy_process()源码分析</h4><p>从上面的分析可以知道，真正创建子进程PCB的操作为<code>copy_process</code>,因为这个方法是在太长，所以只选择重要部分进行分析</p>
<h5 id="1-PCB复制"><a href="#1-PCB复制" class="headerlink" title="(1) PCB复制"></a>(1) PCB复制</h5><img src="http://img.hellofhy.cn/19-1-7/9892081.jpg" width="50%" />


<p>可以看到，真正完成PCB复制工作的方法是<code>dup_task_struct</code>，这里对<code>dup_task_struct</code>的源码进行简单分析:</p>
<img src="http://img.hellofhy.cn/19-1-7/3108309.jpg" width="70%" />

<p>最终执行完<code>dup_task_struct</code>之后，子进程除了<code>tsk-&gt;stack</code>指针与主进程不同之外，其余全部都一样</p>
<h5 id="2-检查上限"><a href="#2-检查上限" class="headerlink" title="(2) 检查上限"></a>(2) 检查上限</h5><img src="http://img.hellofhy.cn/19-1-7/5382753.jpg" width="60%" />

<ul>
<li>通过<code>atomic_read</code>和<code>task_rlimit</code>两个方法来判断进程是否超过上限</li>
<li>通过<code>nr_threads</code>来判断线程是否超过max_threads</li>
</ul>
<h5 id="3-信息复制"><a href="#3-信息复制" class="headerlink" title="(3) 信息复制"></a>(3) 信息复制</h5><img src="http://img.hellofhy.cn/19-1-7/83239058.jpg" width="60%" />

<p>这部分用于复制所有进程信息，包括文件系统、信号处理函数、信号、内存管理等，最后的<code>copy_thread_tls</code>作用是初始化子进程内核栈</p>
<h5 id="4-pid的分配与设置"><a href="#4-pid的分配与设置" class="headerlink" title="(4) pid的分配与设置"></a>(4) pid的分配与设置</h5><img src="http://img.hellofhy.cn/19-1-7/4732954.jpg" width="60%" />

<img src="http://img.hellofhy.cn/19-1-7/35665155.jpg" width="60%" />














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/13/%E4%BA%AC%E4%B8%9C%E3%80%81%E5%A4%B4%E6%9D%A1Android%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/13/%E4%BA%AC%E4%B8%9C%E3%80%81%E5%A4%B4%E6%9D%A1Android%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">Android实习面经(京东、头条)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-13 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-13T00:00:00+08:00">2018-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="今日头条-DATA-挂"><a href="#今日头条-DATA-挂" class="headerlink" title="今日头条-DATA(挂)"></a>今日头条-DATA(挂)</h4><ul>
<li>activity生命周期，透明主题activity对生命周期影响，activity四种启动模式，以及singleTask在什么情况下会变成singleInstance</li>
</ul>
<ul>
<li><p>service两种模式，以及两种模式各自的生命周期，service保活等</p>
</li>
<li><p>多进程通信有几种方式，AIDL了解吗</p>
</li>
<li><p>自定义view、viewGroup用过吗，有哪些需要注意的，view绘制流程源码看过吗，以及测量过程具体是如何实现的</p>
</li>
<li><p>动画类型有几种，插值器用过吗</p>
</li>
<li><p>广播介绍一下</p>
</li>
<li><p>sqlite数据库相关、SharedPreferences相关，sp都能存哪些数据，存数组的时候要注意什么</p>
</li>
<li><p>加密了解吗，了解哪几种加密方式</p>
</li>
</ul>
<ul>
<li>handler源码系列，HandlerThread相关</li>
<li>fragment生命周期，用replace的时候两个fargment生命周期如何变化</li>
<li>接口和抽象类的区别(当时说出了三个)，接口可以放变量吗</li>
<li>java如何实现多线程,如何开启新线程(同说出三个)，如何实现线程同步(说了三种锁和实现细节)</li>
<li>Object类里有哪几个方法，分别都是什么，wait()了解吗，hashCode()有哪些使用场景</li>
</ul>
<h4 id="京东金融（offer）"><a href="#京东金融（offer）" class="headerlink" title="京东金融（offer）"></a>京东金融（offer）</h4><h5 id="提前面"><a href="#提前面" class="headerlink" title="提前面"></a>提前面</h5><ul>
<li>让你实现一个功能，给出一段视频并播放，视频中会提出问题，调用前置摄像头记录使用者的回答并保存，完成时间越快越好<br>  (完成这个demo的好坏对是否能拿offer起决定性作用，实现的好基本上就算过了)</li>
</ul>
<h5 id="视频一面"><a href="#视频一面" class="headerlink" title="视频一面"></a>视频一面</h5><ul>
<li>service用了什么设计模式</li>
<li>restful了解吗</li>
<li>okhttp框架的优点有哪些</li>
<li>如果让你自己设计一套异步请求的流程，采用接口的方式回调，如何实现</li>
<li>如何获取当前线程looper</li>
</ul>
<h5 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h5><ul>
<li>能够实习多久</li>
<li>是否有其他公司offer</li>
<li>期望入职时间</li>
</ul>
<h4 id="今日头条-IES-offer"><a href="#今日头条-IES-offer" class="headerlink" title="今日头条-IES(offer)"></a>今日头条-IES(offer)</h4><h5 id="视频一面-1"><a href="#视频一面-1" class="headerlink" title="视频一面"></a>视频一面</h5><ul>
<li><p>自我介绍、项目介绍</p>
</li>
<li><p>okhttp，retrofit源码看过吗，retrofit如何通过注解使得无须实现接口便可以使用</p>
</li>
<li><p>glide好处是什么，三级缓存介绍一下</p>
</li>
<li><p>activit生命周期相关，新activity启动后两者生命周期的变化</p>
</li>
<li><p>activity之间传递大数据怎么处理（Intent装不下）</p>
</li>
<li><p>binder机制介绍一下</p>
</li>
<li><p>介绍一下mvp、mvvm，mvvm好处是什么</p>
</li>
<li><p>java中char类型多少位，范围，是否有符号，一个中文几个char，float类型多少位、范围、是否有符号</p>
</li>
<li><p>String类的编码格式，如果和后端返回的编码不同怎么处理</p>
</li>
<li><p>手撕代码，用java模拟生产者消费者模型</p>
</li>
<li><p>算法题，非递归中序遍历二叉树</p>
</li>
</ul>
<h5 id="视频二面"><a href="#视频二面" class="headerlink" title="视频二面"></a>视频二面</h5><ul>
<li><p>项目中遇到的困难，聊到了socket，介绍一下socket相关的内容</p>
</li>
<li><p>tcp三次握手四次挥手过程</p>
</li>
<li><p>udp了解吗，有什么好处，和tcp有什么区别</p>
</li>
<li><p>http相关，自己尝试抓过请求包吗，header里有哪些常见的内容</p>
</li>
<li><p>http请求有哪些方法，说说post和get的区别<br></p>
</li>
<li><p>https了解吗</p>
</li>
<li><p>HashMap源码看过吗，内部是怎么实现的，扩容机制了解吗</p>
</li>
<li><p>HashMap的key值有什么要求，不满足的话会导致什么</p>
</li>
<li><p>hashCode()和equal()区别</p>
</li>
<li><p>接口和抽象类的区别，接口中定义的数据都是什么类型的</p>
</li>
<li><p>算法题，判断一棵树是否为平衡二叉树</p>
</li>
</ul>
<h5 id="视频三面"><a href="#视频三面" class="headerlink" title="视频三面"></a>视频三面</h5><ul>
<li><p>多线程相关，如何实现线程同步（各种锁机制详细说）</p>
</li>
<li><p>举一些java工具包中线程安全/不安全的例子，如</p>
<ul>
<li>String、StringBuffer、StringBuider区别</li>
<li>HashMap，HashTable，ConurrentHashMap区别</li>
</ul>
</li>
<li><p>http常见请求方法，常见返回码含义</p>
</li>
<li><p>不与UI绑定的Fragment了解吗，有哪些使用场景</p>
</li>
<li><p>接口和抽象类区别</p>
</li>
<li><p>让你设计一个图片缓存框架，有哪些需要考虑的？（提到了三级缓存）只从内存缓存的角度，用什么数据结构存储最合适，如何比较使用频率，如何清除长时间不用的缓存，如果让你修改hashMap的数据结构，怎么修改效率最高</p>
</li>
</ul>
<h5 id="HR视频面"><a href="#HR视频面" class="headerlink" title="HR视频面"></a>HR视频面</h5><ul>
<li><p>自我介绍一下，提到了在学校工作室的经历，介绍一下你们的工作室</p>
</li>
<li><p>对之前的三次面试总结一下</p>
</li>
<li><p>能实习多长时间</p>
</li>
<li><p>说说你觉得最成功的项目，成功在哪</p>
</li>
<li><p>两个月前面过一次头条一面没过，当时为什么失败</p>
</li>
<li><p>为什么选择android方向</p>
</li>
<li><p>听到我开学刚大三，问我课怎么办，我说可以和老师商量，允许我考试就好</p>
</li>
<li><p>为什么选择搞技术，这么早出来实习</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/20/View%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/20/View%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">View参数相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-20T00:00:00+08:00">2018-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="View相关"><a href="#View相关" class="headerlink" title="View相关"></a>View相关</h2><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-View的位置参数"><a href="#1-View的位置参数" class="headerlink" title="1.View的位置参数"></a>1.View的位置参数</h4><p>Android中X轴和Y轴的正方向分别为右和下</p>
<ul>
<li><strong>left</strong> : 左上角横坐标</li>
<li><strong>top</strong> : 左上角纵坐标</li>
<li><strong>right</strong> : 右下角横坐标</li>
<li><strong>bottom</strong> : 右下角纵坐标</li>
</ul>
<p>可以通过right-left、bottom-top来获取view的宽度和高度</p>
<ul>
<li><strong>translationX</strong> : 左上角横坐标偏移量</li>
<li><strong>translationY</strong> : 左上角纵坐标偏移量</li>
<li><strong>x</strong> : 左上角横坐标(加偏移量后)</li>
<li><strong>y</strong> : 左上角纵坐标(加偏移量后)</li>
</ul>
<p>首先这些坐标都是相对于父容器的坐标，并且都可以通过get/set方法获取到，几个参数的换算关系为:</p>
<pre><code>x = left + translationX    
y = top + translationY</code></pre>
<h4 id="2-MotionEvent-触摸事件"><a href="#2-MotionEvent-触摸事件" class="headerlink" title="2.MotionEvent(触摸事件)"></a>2.MotionEvent(触摸事件)</h4><p>MotionEvent代表触摸屏幕的事件，常见的事件类型有</p>
<ul>
<li><strong>ACTION_DOWN</strong> : 手指按压屏幕</li>
<li><strong>ACTION_MOVE</strong> : 手指在屏幕滑动</li>
<li><strong>ACTION_UP</strong> : 手指离开屏幕</li>
</ul>
<p>获取事件发生位置的方法有:</p>
<ul>
<li><strong>getX()</strong> : 返回相对当前view的横坐标</li>
<li><strong>getY()</strong> : 返回相对当前view的纵坐标</li>
<li><strong>getRawX()</strong> : 返回相对于屏幕左上角的横坐标</li>
<li><strong>getRawY()</strong> : 返回相对于屏幕左上角的纵坐标</li>
</ul>
<h4 id="3-TouchSlop-最小滑动距离"><a href="#3-TouchSlop-最小滑动距离" class="headerlink" title="3.TouchSlop(最小滑动距离)"></a>3.TouchSlop(最小滑动距离)</h4><p>TouchSlop是系统所能识别出的最小滑动距离，获取方式为：</p>
<pre><code>ViewConfiguration.get(MainActivity.this).getScaledTouchSlop();</code></pre>
<h4 id="4-VelocityTracker-速度追踪"><a href="#4-VelocityTracker-速度追踪" class="headerlink" title="4.VelocityTracker(速度追踪)"></a>4.VelocityTracker(速度追踪)</h4><p>使用方法,先初始化，并添加一个触摸事件，然后设置时间间隔并计算:</p>
<pre><code>VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(motionEvent);//添加触摸事件
velocityTracker.computeCurrentVelocity(1000);//设置事件间隔并计算速度
float xVelocity = velocityTracker.getXVelocity();//获取水平方向移动速度
float yVelocity = velocityTracker.getYVelocity();//获取竖直方向移动速度</code></pre>
<p>计算方式为: 速度 = (终点坐标-起始坐标) / 时间间隔，即在1000ms内水平滑动过的像素为100，则水平速度为100px/s,注意在<br>不需要的时候调用<code>velocityTracker.clear()</code>来回收内存。</p>
<h4 id="5-GestureDetector-手势检测"><a href="#5-GestureDetector-手势检测" class="headerlink" title="5.GestureDetector(手势检测)"></a>5.GestureDetector(手势检测)</h4><p>GestureDetector主要用于检测用户的手势动作，使用的时候可以让被监听的view实现两个接口：<code>OnGestureListener</code>和<code>OnDoubleTapListener</code>,接下来看看两个接口中的几个回调方法:</p>
<ul>
<li><p><strong>OnGestureListener</strong></p>
<ul>
<li>onDown(MotionEvent e) : 手指触摸屏幕瞬间触发</li>
<li>onShowPress(MotionEvent e) : 手指触摸屏幕但未松开的状态</li>
<li>onSingleTapUp(MotionEvent e) : 手指离开屏幕时触发</li>
<li>onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) : 手指按下屏幕并拖动</li>
<li>onLongPress(MotionEvent e) : 手指长按屏幕事件</li>
<li>onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) : 快速滑动事件</li>
</ul>
</li>
<li><p><strong>OnDoubleTapListener</strong></p>
<ul>
<li>onSingleTapConfirmed(MotionEvent e) : 严格的单击事件，不是双击事件中的一个点击</li>
<li>onDoubleTap(MotionEvent e) : 双击，由两次单击组成，不能和onSingleTapConfirmed共存</li>
<li>onDoubleTapEvent(MotionEvent e) : 表示发生了双击事件</li>
</ul>
</li>
</ul>
<h3 id="二、view的分发机制"><a href="#二、view的分发机制" class="headerlink" title="二、view的分发机制"></a>二、view的分发机制</h3><p>view的分发机制是面试中经常会问到的问题，也是后面解决view滑动冲突的理论基础，接下来会从源码角度对整个事件的分发机制进行简单分析。<br>事件分发实际上就是把一个MotionEvent事件传递给一个具体的view的过程，其中涉及到三个很重要的方法 : </p>
<ul>
<li><strong>boolean dispatchTouchEvent(MotionEvent ev)</strong> : 该方法主要用于事件的分发，即事件传递到当前view时被调用，返回值受当前view的<code>onTouchEvent</code>和子view的<code>dispatchTouchEvent</code>返回值影响，true表示事件已经被消耗，false表示事件未被消耗。</li>
</ul>
<ul>
<li><strong>boolean onInterceptTouchEvent(MotionEvent ev)</strong> : 在<code>dispatchTouchEvent</code>中被调用，表示是否拦截当前事件，只有ViewGroup才有，并且默认返回false。如果一个View决定拦截事件，那么整个事件序列都将交给这个view去处理，并且后续的事件都不会再调用<code>onInterceptTouchEvent</code>方法。</li>
</ul>
<ul>
<li><strong>boolean onTouchEvent(MotionEvent event)</strong> : 在<code>dispatchTouchEvent</code>中被调用，表示消耗事件，返回结果表示是否消耗成功，如果一个view消耗了一个<code>ACTION_DOWN</code>事件，那么后续的事件序列都会交给这个view去处理，否则该view将不会处理后续事件。</li>
</ul>
<p>三个方法的关系可以用如下伪代码来表示 : </p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) &#123;

        boolean consume = false;

        //首先判断是否需要拦截该事件
        if (onInterceptTouchEvent(ev)) &#123;
            //如果拦截交给自己处理
            consume = onTouchEvent(ev);
        &#125; else &#123;
            //不拦截则交给子view处理
            consume = child.dispatchTouchEvent(ev);
        &#125;
        return consume;
    &#125;</code></pre>
<p>下面从事件分发的顺序对源码进行简单分析 : </p>
<h4 id="1-activity对事件的分发"><a href="#1-activity对事件的分发" class="headerlink" title="1.activity对事件的分发"></a>1.activity对事件的分发</h4><p>首先来看看activity里面的<code>dispatchTouchEvent</code>方法具体做了哪些事</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) &#123;
    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;
        onUserInteraction();
    &#125;
    if (getWindow().superDispatchTouchEvent(ev)) &#123;
        return true;
    &#125;
    return onTouchEvent(ev);
&#125;</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/14/%E4%BA%86%E8%A7%A3Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/14/%E4%BA%86%E8%A7%A3Service/" class="post-title-link" itemprop="url">从Service聊到IPC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-14 00:00:00" itemprop="dateCreated datePublished" datetime="2018-06-14T00:00:00+08:00">2018-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--## 从Service聊到IPC-->

<p>Service属于四大组件之一，是一种不需要用户界面的计算类型组件，可以在后台执行长时间操作，例如网络请求、播放音乐、文件IO操作等。但实际上service并不是一个进程，除非注册时特殊指定，否则它和其他组件依然处于同一个进程，同时service也不是一个线程，其内部逻辑依然运行在主线程，所以当需要进行耗时操作时依然需要创建子线程。service一般有两种状态:<strong>启动状态</strong>和<strong>绑定状态</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/06/14/%E4%BA%86%E8%A7%A3Service/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/02/Java%E5%9F%BA%E7%A1%80%E4%B9%8B-JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/02/Java%E5%9F%BA%E7%A1%80%E4%B9%8B-JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Java基础之-JVM-内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-02 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-02T00:00:00+08:00">2018-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Java基础之-JVM-内存模型"><a href="#Java基础之-JVM-内存模型" class="headerlink" title="Java基础之-JVM-内存模型"></a>Java基础之-JVM-内存模型</h3><p>Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： </p>
<ul>
<li>程序计数器 </li>
<li>Java虚拟机栈 </li>
<li>本地方法栈 </li>
<li>堆 </li>
<li>方法区</li>
</ul>
<p><img src="http://img.hellofhy.cn/18-5-1/10538549.jpg"></p>
<h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h4><ul>
<li><p>概念 : 程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。 但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。  </p>
</li>
<li><p>作用 : </p>
<ul>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
</li>
<li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 </p>
</li>
</ul>
</li>
<li><p>特点 : </p>
<ul>
<li>是一块较小的存储空间</li>
<li>线程私有。每条线程都有一个程序计数器。</li>
<li>是唯一一个不会出现OutOfMemoryError的内存区域。</li>
<li>生命周期随着线程的创建而创建，随着线程的结束而死亡。 </li>
</ul>
</li>
</ul>
<h4 id="2-Java虚拟机栈-JVM-Stack"><a href="#2-Java虚拟机栈-JVM-Stack" class="headerlink" title="2. Java虚拟机栈(JVM Stack)"></a>2. Java虚拟机栈(JVM Stack)</h4><p>Java虚拟机栈是描述Java方法运行过程的内存模型。与程序计数器一样，Java虚拟机栈也是线程私有的，用通俗的话将它就是我们常常听说到堆栈中的那个“栈内存”。</p>
<p>Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做<strong>“栈帧”</strong>的区域，每一个方法从调用至出栈的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程。这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：</p>
<ul>
<li>局部变量表（局部变量表需要的内存在编译期间就确定了所以在方法运行期间不会改变大小）</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口等</li>
</ul>
<blockquote>
<p>注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。<br>这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。 </p>
</blockquote>
<h4 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h4><p>本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间。</p>
<h4 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h4><ul>
<li><p>作用 : 堆是用来存放对象的内存空间。 几乎所有的对象都存储在堆中。 </p>
</li>
<li><p>特点 : </p>
<ul>
<li><p>线程共享 </p>
<p>  整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的。</p>
</li>
<li><p>在虚拟机启动时创建</p>
</li>
<li><p>垃圾回收的主要场所。</p>
</li>
<li><p>可以进一步细分为：新生代、老年代。 </p>
<p>  新生代又可被分为：Eden、From Survior、To Survior。<br>不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。</p>
</li>
<li><p>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。 </p>
</li>
</ul>
</li>
</ul>
<h4 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h4><ul>
<li>概念 : Java虚拟机规范中定义方法区是堆的一个逻辑部分。<br>方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。</li>
</ul>
<ul>
<li><p>特点 : 方法区的特点</p>
<ul>
<li><p>线程共享 </p>
<p>  方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</p>
</li>
<li><p>永久代 </p>
<p>  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。</p>
</li>
<li><p>内存回收效率低 </p>
<p>  方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。</p>
</li>
<li><p>Java虚拟机规范对方法区的要求比较宽松。 </p>
<p>  和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 </p>
</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。<br>两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。<br>只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。</p>
</li>
<li><p>Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。</p>
</li>
<li><p>堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。</p>
</li>
<li><p>程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。<br>而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。</p>
</li>
</ul>
<p> <a target="_blank" rel="noopener" href="http://developer.51cto.com/art/200911/165015.htm">JVM基础概念总结：数据类型、堆与栈</a></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/genius_ge/article/details/76151179">JVM内存模型详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/01/Java%E5%9F%BA%E7%A1%80%E4%B9%8B-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/01/Java%E5%9F%BA%E7%A1%80%E4%B9%8B-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java基础之-JVM-类加载机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-01T00:00:00+08:00">2018-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##Java基础之-JVM-类加载机制</p>
<p>概念: 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是Java的类加载机制。</p>
<p>在Java语言中，类的加载，连接和初始化过程都是在程序运行期间完成的(动态性)，这样虽然会增加类的加载性能开销，但是这也为java应用程序提供高度的灵活性。</p>
<h4 id="1、类加载过程"><a href="#1、类加载过程" class="headerlink" title="1、类加载过程"></a>1、类加载过程</h4><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了：**加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)**七个阶段，其中验证、准备、解析三个部分统称链接。<br><img src="http://img.hellofhy.cn/18-5-1/89563219.jpg"></p>
<h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><ul>
<li><p><strong>(1)加载 : 查找并加载类的二进制数据</strong></p>
<p>  加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li><p>通过一个类的全类名来获取定义此类的二进制字节流</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
</li>
<li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口</p>
<blockquote>
<p>相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p>
</blockquote>
<blockquote>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在java堆中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h5><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段还未结束，连接阶段可能已经开始，这部分夹杂在加载阶段进行的动作，依然属于连接阶段的内容，并且加载阶段必定早于连接阶段开始</p>
<ul>
<li><p><strong>(2)验证 : 确保被加载的类的正确性</strong> </p>
<ul>
<li><p><strong>文件格式验证</strong> : 第一阶段要验证字节流是否符合Class文件格式的规范，例如：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主次版本号是否在当前虚拟机的处理范围之内</li>
<li>常量池中的常量是否有不被支持的类型</li>
</ul>
</li>
<li><p><strong>元数据验证</strong>: 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范的要求，例如:</p>
<ul>
<li>一个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类</li>
<li>如果这个类不是抽象类，是否实现了其父类或者接口要求实现的所有的方法</li>
<li>类中的字段，方法是否与父类产生矛盾</li>
</ul>
</li>
<li><p><strong>字节码验证</strong>: 第三阶段主要目的是通过数据流和控制流分析，确定程序语法是否是合法的，符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时候不会做出对虚拟机有危害的事情。例如:</p>
<ul>
<li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型则是危险的</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这种情况：在操作栈中放置一个int类型数据，使用却将他按照long类型使用</li>
</ul>
</li>
<li><p><strong>符号引用验证</strong>: 第四阶段的校验确保解析动作能正确执行,发生在虚拟机将符号引用转化为直接引用的时候，这个转换动作发生在连接的第三阶段–解析中发生，符号引用可以看做是对类自身以外的信息进行匹配性校验，例如:</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类，字段，方法的访问性是否可以被当前类访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>(3)准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p>
<p>  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li><p>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
</li>
<li><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>  假设一个类变量的定义为：<code>public static int value = 3</code></p>
<p>  那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<p>  <img src="http://p0y1qzu73.bkt.clouddn.com/18-5-1/90110776.jpg"></p>
</li>
<li><p>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p>  假设上面的类变量value被定义为： <code>public static final int value = 3</code></p>
<p>  编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。</p>
</li>
</ul>
</li>
<li><p><strong>(4)解析 : 把类中的符号引用转换为直接引用</strong> </p>
<ul>
<li><p><strong>符号引用</strong> : 符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。</p>
</li>
<li><p><strong>直接引用</strong> : 直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<p>解析的动作主要针对四类符号引用进行。分别对应编译后常量池内的四种常量类型。</p>
</li>
<li><p>类、接口的解析(CONSTANT_Class_Info)</p>
</li>
<li><p>字段解析(CONSTANT_Fieldref_Info)</p>
</li>
<li><p>类方法解析(CONSTANT_Methodef_Info)</p>
</li>
<li><p>接口方法解析(CONSTANT_InterfaceMethoder_Info)</p>
</li>
</ul>
</li>
</ul>
<h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><ul>
<li><p><strong>(5)初始化:</strong> </p>
<p>  类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</p>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生的，他按照代码中出现的顺序收集，静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的，在静态语句块中只能赋值不能访问,例如:</p>
<pre><code>  public class Test &#123;
      static&#123;
          i = 1;//可以赋值
          System.out.println(i);//不能访问
      &#125;
      static int i = 0;
  &#125;</code></pre>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法在执行之前必须保证自己父类的类构造器方法已经执行完毕,因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法，但是接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父类接口的<code>&lt;clinit&gt;()</code>方法，只有父类接口中定义的变量使用时父类接口才会初始化，另外接口实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁，同步。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2、类加载器"><a href="#2、类加载器" class="headerlink" title="2、类加载器"></a>2、类加载器</h4><p>概念 : JVM设计者把类加载阶段中的“通过’类全名’来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h5 id="1-类与类加载器"><a href="#1-类与类加载器" class="headerlink" title="(1)类与类加载器"></a>(1)类与类加载器</h5><p>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p>
<h5 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="(2)双亲委派模型"></a>(2)双亲委派模型</h5><blockquote>
<p>从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：</p>
</blockquote>
<ul>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载<code>JAVA_HOME\lib</code>目录中的、并且能被虚拟机识别的类库到JVM内存中(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）,如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。</p>
</li>
<li><p><strong>扩展类加载器（Extension ClassLoader）</strong>：该加载器主要是负责加载<code>JAVA_HOME\lib\</code>，该加载器可以被开发者直接使用。</p>
</li>
<li><p><strong>应用程序类加载器（Application ClassLoader）</strong>：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>我们的应用程序都是由这三类加载器互相配合进行加载的，我们也可以加入自己定义的类加载器。这些类加载器之间的关系如下图所示：</p>
<p><img src="http://img.hellofhy.cn/18-5-1/12560359.jpg"></p>
<p>如上图所示的类加载器之间的这种层次关系，就称为类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。</p>
<blockquote>
<p>双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。在ClassLoader源码里也可以看出：</p>
</blockquote>
<pre><code>public abstract class ClassLoader &#123;

    protected Class&lt;?&gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    &#123;
            //首先，检查该类是否已经被加载
            Class c = findLoadedClass(name);
            if (c == null) &#123;
                long t0 = System.nanoTime();
                try &#123;
                    //先调用父类加载器去加载
                    if (parent != null) &#123;
                        c = parent.loadClass(name, false);
                    &#125; else &#123;
                        c = findBootstrapClassOrNull(name);
                    &#125;
                &#125; catch (ClassNotFoundException e) &#123;
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                &#125;

                if (c == null) &#123;
                    //如果父类加载器没有加载到该类，则自己去执行加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                &#125;
            &#125;
            return c;
    &#125;
&#125;</code></pre>
<p>通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p>
<blockquote>
<p>使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。</p>
</blockquote>
<p>参考博客 : </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/boyupeng/article/details/47951037">JVM（三）：类加载机制（类加载过程和类加载器）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/5603287.html">java类的加载机制</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/21/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/21/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Java多线程整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-21 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-21T00:00:00+08:00">2018-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h3><ul>
<li>并发:在同一个时间段内，同一个cpu上执行多个任务，但在某一时刻cpu只处理一个任务。</li>
<li>并行:同一时间段内，多个cpu执行多个任务，在某一时刻有多个任务同时执行，并且相互之间没有干扰。</li>
</ul>
<p>这里再详细说一下并发时任务是如何调度的，引用一下博客：</p>
<blockquote>
<p>大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。</p>
</blockquote>
<p><img src="http://img.hellofhy.cn/18-3-31/32283692.jpg"></p>
<p>在多个任务中切换也是要付出代价的,一个任务消耗完了时间片，需要根据调度策略来选取下一个任务来执行，而这一过程也需要消耗时间，叫做<strong>切换耗时</strong>,而这也将影响时间片大小的选取。</p>
<ul>
<li><p><strong>进程</strong>：进程代表一个运行中的程序，是资源分配与调度的基本单位。进程有三大特性：</p>
<ul>
<li>独立性：独立的资源，私有的地址空间，进程间互不影响。</li>
<li>动态性：进程具有生命周期。</li>
<li>并发性：多进程可以在单核CPU上并发运行。</li>
</ul>
</li>
<li><p><strong>线程</strong>：线程代表进程中的一个顺序执行流，多线程就是一个进程中的多个顺序执行流。线程也被称为轻量级的进程，是系统运行的基本单位。</p>
</li>
<li><p><strong>多线程的优势</strong>（进程线程区别）：</p>
<ul>
<li>进程之间不能共享内存，线程之间共享内存更容易，多线程可协作完成进程工作；</li>
<li>创建进程进行资源分配的代价较创建线程要大得多，所以多线程在高并发环境中效率更高。</li>
</ul>
</li>
</ul>
<h3 id="2、使用多线程"><a href="#2、使用多线程" class="headerlink" title="2、使用多线程"></a>2、使用多线程</h3><p>三种使用方法 :</p>
<ul>
<li><p><strong>Thread</strong> : 新建子类继承Thread类，重写run方法</p>
<pre><code>  public class MyThread extends Thread&#123;

      @Override
      public void run() &#123;

      &#125;
  &#125;</code></pre>
<p>  在使用的时候直接创建实例并开启即可</p>
<pre><code>  Thread myThread = new MyThread();
  myThread.start();</code></pre>
</li>
</ul>
<ul>
<li><p><strong>Runnable</strong> : 新建子类实现Runnable接口，重写run方法。实例化后作为参数传入<code>Thread()</code>的构造方法中(也可以使用匿名内部类实现)。</p>
<pre><code>  //1、继承接口实现
  public class MyThread implements Runnable&#123;

      @Override
      public void run() &#123;

      &#125;
  &#125;

  //使用直接传入Thread
  new Thread(new MyThread()).start();</code></pre>
</li>
</ul>
<pre><code>    //2、匿名内部类实现
    new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;

        &#125;
    &#125;).start();</code></pre>
<ul>
<li><strong>Callable</strong>:实现<code>Callable</code>接口并指定返回的参数</li>
</ul>
<pre><code>    public class MyCallable implements Callable&lt;String&gt; &#123;

        @Override
        public String call() throws Exception &#123;
            Thread.sleep(1000);
            return &quot;hello&quot;;
        &#125;
    &#125;


使用的时候需要通过FutureTask

    Callable callable = new MyCallable();
    FutureTask futureTask = new FutureTask&lt;&gt;(callable);
    new Thread(futureTask).start();


可以看到`Callable`接口和`Runnable`接口中实现方法的区别，
+ call()方法中可以指定一个返回值，可以通过FutureTask对象的get()来获取call()中的返回值，此方法会阻塞线程知道获得“将来”的结果，不调用此方法，主线程不会阻塞。
+ call()可以抛出受检查的异常</code></pre>
<h3 id="3、常用函数"><a href="#3、常用函数" class="headerlink" title="3、常用函数"></a>3、常用函数</h3><ul>
<li><p><code>sleep()</code> : 使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。</p>
</li>
<li><p><code>yield()</code> : 该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。</p>
</li>
<li><p><code>isAlive()</code>: 当前线程没有执行完run方法，即没有进入死亡状态的时候返回ture，<br>否则返回fasle。</p>
</li>
<li><p><code>currentThread()</code> : 返回当前正在使用CPU资源的线程。</p>
</li>
<li><p><code>start()</code>: 线程调用该方法将启动线程，使之从新建状态进入就绪队列排队，一旦轮到它来享用CPU资源时，就可以脱离创建它的线程独立开始自己的生命周期了。注意一个线程不能重复调用<code>start()</code>。</p>
</li>
<li><p><code>run()</code>: Thread类的run()方法与Runnable接口中的run()方法的功能和作用相同，都用来定义线程对象被调度之后所执行的操作</p>
<blockquote>
<p>为什么不能用run开启线程:run方法应该由系统自动调用，如果在主线程中调用就变成了同步方法。</p>
</blockquote>
</li>
<li><p><code>join()</code>:线程合并，即该线程执行完毕才能继续执行调用join()方法所在的线程。</p>
</li>
<li><p><code>setPriority()</code>: 设置一个线程的优先级,范围是1~10。</p>
</li>
</ul>
<h3 id="4、线程生命周期"><a href="#4、线程生命周期" class="headerlink" title="4、线程生命周期"></a>4、线程生命周期</h3><p>首先看一下下面这张较为经典的图</p>
<p><img src="http://img.hellofhy.cn/19-1-12/56161691.jpg"></p>
<ul>
<li><strong>新建状态（New）</strong>：当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。</li>
</ul>
<ul>
<li><p><strong>就绪状态（Runnable）</strong>：当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。</p>
</li>
<li><p><strong>运行状态（Running）</strong>: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p><strong>阻塞状态（Blocked）</strong>:阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种</p>
<ul>
<li><p><strong>等待阻塞</strong>：运行的线程执行wait()方法，JVM会把该线程放入等待池中。</p>
</li>
<li><p><strong>同步阻塞</strong>：运行的线程在获取对象的<code>synchronized</code>同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</p>
</li>
<li><p><strong>其他阻塞</strong>：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>死亡状态（Dead）</strong> : 线程会以以下三种方式之一结束，结束后就处于死亡状态<ul>
<li>run()方法执行完成，线程正常结束。</li>
<li>线程抛出一个未捕获的Exception或Error。</li>
<li>直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。</li>
</ul>
</li>
</ul>
<h3 id="5、线程分类"><a href="#5、线程分类" class="headerlink" title="5、线程分类"></a>5、线程分类</h3><ul>
<li><p><strong>用户线程(User) :</strong> 非守护线程包括常规的用户线程或诸如用于处理GUI事件的事件调度线程，Java虚拟机在它所有非守护线程已经离开后自动离开。</p>
</li>
<li><p><strong>守护线程(Daemon) :</strong> 守护线程则是用来服务用户线程的，如果没有其他用户线程在运行，那么就没有可服务对象，也就没有理由继续下去。举例来说，JVM的垃圾回收**(GC线程)**、内存管理等线程都是守护线程。</p>
<blockquote>
<p>操作系统里面是没有所谓的守护线程的概念，只有守护进程一说，但是Java语言机制是构建在JVM的基础之上的，意思是Java平台把操作系统的底层给屏蔽起来，所以它可以在它自己的虚拟的平台里面构造出对 自己有利的机制，而语言或者说平台的设计者多多少少是受到Unix思想的影响，而守护线程机制又是对JVM这样的平台凑合，于是守护线程应运而生</p>
</blockquote>
</li>
</ul>
<h5 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h5><p>两者的区别之处在于虚拟机的离开，当JVM中所有的线程都是守护线程的时候，JVM就可以退出了（如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了）；如果还有一个或以上的非守护线程则不会退出。（以上是针对正常退出，调用System.exit则必定会退出）。</p>
<h5 id="开启一个守护线程"><a href="#开启一个守护线程" class="headerlink" title="开启一个守护线程"></a>开启一个守护线程</h5><p>守护线程与普通线程写法上基本没什么区别，调用线程对象的方法<code>setDaemon(true)</code>，则可以将其设置为守护线程。</p>
<ul>
<li><p><code>thread.setDaemon(true)</code>必须在<code>thread.start()</code>之前设置,你不能把正在运行的常规线程设置为守护线程,否则会跑出一个<code>IllegalThreadStateException</code>异常，如果线程是守护线程，则<code>isDaemon</code>方法返回true。</p>
<blockquote>
<p>这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别</p>
</blockquote>
</li>
</ul>
<ul>
<li>在Daemon线程中产生的新线程也是Daemon的。    <blockquote>
<p>这一点又是有着本质的区别了：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”</p>
</blockquote>
</li>
</ul>
<ul>
<li>不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。 </li>
</ul>
<p>例子:</p>
<pre><code>public static void main(String[] args) throws InterruptedException &#123;

    Thread thread = new Thread(new MyThread());
    thread.setDaemon(true);
    thread.start();
&#125;


static class MyThread implements Runnable &#123;

    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;test&quot;);
    &#125;
&#125;</code></pre>
<p>运行后会发现并没有输出任何内容，证明用户线程全部离开后，无论守护线程处于什么状态都会随之退出。</p>
<h3 id="6、线程同步"><a href="#6、线程同步" class="headerlink" title="6、线程同步"></a>6、线程同步</h3><p>线程不安全的例子:</p>
<pre><code>public class ThreadOne implements Runnable &#123;

    public static int count = 0;

    public void increase() &#123;
        count++;
    &#125;

    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100000; i++) &#123;
            increase();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(new ThreadOne());
        Thread t2 = new Thread(new ThreadOne());
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(count);//输出结果为146066
    &#125;
&#125;</code></pre>
<p>count++不是原子操作，该操作是先读取值，然后写回一个新值，相当于原来的值加上1。当线程1刚进行完第一步，线程2同样进行了第一步操作，这时获取到的count仍然是原来未增加的数值，当两者都完成第二步写入新值的时候，写入的其实是一样的值,这样就造成了数值的丢失，这时候就需要引入锁的机制，将多个线程能访问的方法变成同步方法。</p>
<h4 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="(1)synchronized"></a>(1)synchronized</h4><p>synchronized是Java中的关键字，是一种同步锁。</p>
<ul>
<li><p>synchronized实例方法 ：同步方法，作用于当前实例，即进入同步代码会获得当前实例的锁(对象锁)。</p>
</li>
<li><p>synchronized静态方法 ：同步静态方法，作用于当前类，即进入同步代码会获得当前类对象的锁(类锁)。</p>
</li>
<li><p>synchronized()代码块：可以指定加锁对象，既可以是实例对象也可以是类对象。</p>
</li>
</ul>
<ul>
<li><p><strong>对象锁</strong>：Java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。</p>
</li>
<li><p><strong>类锁</strong>：对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个 java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是MyClass.class的方式。 </p>
</li>
</ul>
<blockquote>
<p>一个是类的Class对象的锁，一个是类的实例的锁。也就是说：一个线程访问静态synchronized的时候，允许另一个线程访问对象的实例synchronized方法。反过来也是成立的，因为他们需要的锁是不同的。</p>
</blockquote>
<h4 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h4><p>当两个或两个以上进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们将一直阻塞下去。</p>
<p>例如：线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p>
<p><strong>产生死锁的四个必要条件</strong>：</p>
<ul>
<li><p>互斥条件：一个资源每次只能被一个进程使用。</p>
</li>
<li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</p>
</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ul>
<p>写一个死锁的例子:</p>
<pre><code>public class DeadClock &#123;

    private static Object sLockA = new Object();

    private static Object sLockB = new Object();

    public static void main(String[] args) throws InterruptedException &#123;
        new DeadClock().deadLock();
    &#125;

    @SuppressWarnings(&quot;all&quot;)
    public void deadLock() &#123;

        Thread t1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                synchronized (sLockA) &#123;
                    System.out.println(&quot;线程1获取A锁&quot;);
                    try &#123;
                        Thread.sleep(2000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                    System.out.println(&quot;线程1等待B锁释放&quot;);

                    synchronized (sLockB) &#123;
                        System.out.println(&quot;thread1...&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;);

        Thread t2 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                synchronized (sLockB) &#123;
                    System.out.println(&quot;线程2获取B锁，等待A锁释放&quot;);
                    synchronized (sLockA) &#123;
                        System.out.println(&quot;thread2...&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;);

        t1.start();
        t2.start();
    &#125;
&#125;</code></pre>
<p>运行后程序出现死锁</p>
<p><img src="http://img.hellofhy.cn/18-4-21/4196162.jpg"></p>
<p>避免出现死锁的方式:</p>
<ul>
<li><p>避免一个线程同时获取多个锁</p>
</li>
<li><p>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</p>
</li>
<li><p>尝试使用定时锁，使用lock.tryLock来代替使用内置锁。</p>
</li>
</ul>
<h4 id="3-wait、notify和notifyAll"><a href="#3-wait、notify和notifyAll" class="headerlink" title="(3)wait、notify和notifyAll"></a>(3)wait、notify和notifyAll</h4><ul>
<li><p>wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</p>
</li>
<li><p>一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法。</p>
</li>
<li><p>由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。<br>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。<br>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。<br>也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程 </p>
</li>
</ul>
<ul>
<li><p><code>wait</code>：使持有该对象的线程把该对象的控制权交出去，然后处于等待状态（也就是说当调用wait的时候会释放锁并处于等待的状态）</p>
</li>
<li><p><code>notify</code>：通知某个正在等待这个对象的控制权的线程可以继续运行（这个就是获取锁，使自己的程序开始执行，最后通过notify同样去释放锁，并唤醒正在等待的线程）</p>
</li>
<li><p><code>notifyAll</code>:会通知所有等待这个对象控制权的线程继续运行(和上面一样，只不过是唤醒所有等待的线程继续执行)</p>
</li>
</ul>
<p>这个就好了，从上面的解释我们可以看出通过wait和notify可以做线程之间的通信，当A线程处理完毕通知B线程执行，B线程执行完毕以后A线程可以继续执行。</p>
<p><strong>实例 : 生产者消费者模型</strong></p>
<p>基于等待/通知机制。生产者/消费者模型描述的是有一块缓冲区作为仓库，生产者可将产品放入仓库，消费者可以从仓库中取出产品，生产者/消费者模型关注的是以下几个点：</p>
<ul>
<li><p>一个生产者或消费者工作的时候其他人不能工作。</p>
</li>
<li><p>缓冲区空时消费者不能消费</p>
</li>
<li><p>缓冲区满时生产者不能生产</p>
</li>
</ul>
<p><img src="http://img.hellofhy.cn/18-4-21/5146865.jpg"></p>
<p><img src="http://img.hellofhy.cn/18-4-21/14097141.jpg"></p>
<h4 id="4-volatile"><a href="#4-volatile" class="headerlink" title="(4)volatile"></a>(4)volatile</h4><p>volatile是java中一种轻量级的同步机制，它的作用是保证线程之间共享变量的可见性，当线程A修改了一个volatile修饰的共享变量之后，线程B会读取该变量时，会获得一个修改后的正确值。</p>
<p><strong>(1)如何保证内存可见性</strong>: 在java虚拟机的内存模型中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存的数据。</p>
<ul>
<li><p>对于普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主内存中拷贝一份数据到工作内存中；写操作只会修改工作内存的副本数据，这种情况下，其它线程就无法读取变量的最新值。</p>
</li>
<li><p>对于volatile变量，读操作时JMM会把工作内存中对应的值设为无效，要求线程从主内存中读取数据；写操作时JMM会把工作内存中对应的数据刷新到主内存中，这种情况下，其它线程就可以读取变量的最新值。</p>
</li>
</ul>
<p><strong>(2)不能保证原子性</strong>: volatile关键字虽然能保证变量在线程间的可见性，但是并不能保证原子性。</p>
<p>原子性指的是一个操作具有在执行过程中不会被任何因素打断的性质。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。例如 <code>i=0</code> 这个操作是不可分割的，所以是原子操作，但是i++则不是，他的操作分为三步：</p>
<ul>
<li>从主内存中取出i的值</li>
<li>i自增1</li>
<li>将i存到主内存</li>
</ul>
<p>原子性的线程不安全在介绍synchronized时已经说过，下面来看看volatile为什么不能保证原子操作的线程安全:</p>
<pre><code>public class Test &#123;

    public volatile int inc = 0;

    public void increase() &#123;
        inc++;
    &#125;

    public static void main(String[] args) &#123;
        final Test test = new Test();
        for (int i = 0; i &lt; 10; i++) &#123;

            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    for (int j = 0; j &lt; 1000; j++) &#123;
                        test.increase();
                    &#125;
                &#125;
            &#125;).start();

        &#125;
        while (Thread.activeCount() &gt; 1) &#123;
            Thread.yield();
        &#125;

        System.out.println(test.inc);//输出值为9933
    &#125;
&#125;</code></pre>
<p>虽然volatile可以让每个线程读取的变量都是最新的，但是可以看到，依然不能保证线程安全,下面进行一下模拟:</p>
<ul>
<li>目前inc的值为10，线程1从主工作区中获取最新值，但是还没有来得及进行自增操作就线程1就进入阻塞状态</li>
<li>此时线程2开始进入运行状态，从主工作区中获取inc的值依然为10，自增后写入主工作区，之后进入阻塞状态。</li>
<li>线程1重新进入运行状态，完成自增并写入工作区内存。</li>
</ul>
<p>这时候inc的值为11，说明volatile无法保证原子操作的线程安全。</p>
<p><strong>(3)保证有序性</strong>：</p>
<p><strong>什么是指令重排</strong> : 指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。</p>
<p>不同的指令间可能存在数据依赖。比如下面计算圆的面积的语句：</p>
<pre><code>double r = 2.3d;//(1)

double pi =3.1415926; //(2)

double area = pi* r * r; //(3)</code></pre>
<p>area的计算依赖于r与pi两个变量的赋值指令。而r与pi无依赖关系，即计算顺序(1)(2)(3)与(2)(1)(3) 对于r、pi、area变量的结果并无区别。编译器、Runtime在优化时可以根据情况重排序（1）与（2），而丝毫不影响程序的结果。但要注意的是指令重排必须要在不影响最终结果的前提下进行。</p>
<p>volatile的另一个特点便是能够禁止指令重排，从而在一定程度上保证程序的有序性:</p>
<ul>
<li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作一定还未进行</li>
<li>在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li>
</ul>
<pre><code>    public static int a,b;
    public static volatile boolean c;

    public static void main(String[] args) &#123;

        a = 1; //语句1
        b = 2; //语句2
        c = true; //语句3
        a = 3; //语句4
        b = 4; //语句5
    &#125;</code></pre>
<p>在指令重排的过程中，语句3不会在语句1或者语句2的前面执行，也不会在语句4或者语句5的后面执行，但是1和2之间以及4和5之间的顺序依然是不能保证的。同时当语句1、2执行完之后的结果对语句3、4、5都是可见的。</p>
<h3 id="7、线程局部变量ThreadLocal"><a href="#7、线程局部变量ThreadLocal" class="headerlink" title="7、线程局部变量ThreadLocal"></a>7、线程局部变量ThreadLocal</h3><p>ThreadLocal是一个关于创建线程局部变量的类。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。</p>
<p>具体的实现原理我们来看一看这两个类的get()和set()方法源码</p>
<pre><code>public void set(T value) &#123;  
       Thread t = Thread.currentThread();  
       ThreadLocalMap map = getMap(t);  
       if (map != null)  
           map.set(this, value);  
       else  
           createMap(t, value);  
&#125;  </code></pre>
<p>set方法首先通过<code>Thread.currentThread()</code>方法来获取当前线程，然后取出当前线程对象的成员变量<code>ThreadLocalMap</code>,如果存在就设置键值对，其中key为ThreadLocal本身，value为想要设置的值，如果不存在就创建一个</p>
<pre><code>public T get() &#123;  
    Thread t = Thread.currentThread();  
    ThreadLocalMap map = getMap(t);  
    if (map != null) &#123;  
        ThreadLocalMap.Entry e = map.getEntry(this);  
        if (e != null) &#123;  
            T result = (T)e.value;  
            return result;  
        &#125;  
    &#125;  
    return setInitialValue();  
&#125;

ThreadLocalMap getMap(Thread t) &#123;
    return t.threadLocals;
&#125;  </code></pre>
<p>然后来看看get方法，从代码中可以看出ThreadLocalMap中存放的就是Entry，Entry的KEY就是ThreadLocal，VALUE就是值。而map是从Thread t中获得的。也就是说map虽然是在threadlocal的内部类，但是却是保存在Thread中的。</p>
<p>下面来看一下使用场景:</p>
<p><img src="http://img.hellofhy.cn/18-4-22/40318473.jpg"></p>
<p><img src="http://img.hellofhy.cn/18-4-22/82361554.jpg"></p>
<p>可以看到在不同的线程中创建了独立的变量副本。</p>
<h3 id="8、线程池"><a href="#8、线程池" class="headerlink" title="8、线程池"></a>8、线程池</h3><p>在开发过程中，不推荐显示的创建新线程，而是推荐使用线程池的方法进行线程的处理，这样可以避免频繁的创建销毁线程带来的资源的损耗，<br>在java中线程池的实现类为<code>ThreadPoolExecutor</code> ，其构造方法的参数为:</p>
<pre><code>ThreadPoolExecutor mExecutor = new ThreadPoolExecutor(corePoolSize,// 核心线程数  
                        maximumPoolSize, // 最大线程数  
                        keepAliveTime, // 闲置线程存活时间  
                        TimeUnit.MILLISECONDS,// 时间单位  
                        new LinkedBlockingDeque&lt;Runnable&gt;(),// 线程队列  
                        Executors.defaultThreadFactory(),// 线程工厂  
                        new AbortPolicy()// 队列已满,而且当前线程数已经超过最大线程数时的异常处理策略  
                );  </code></pre>
<p>可以直接创建java中四种配置好参数的线程池:</p>
<ul>
<li><strong>FixedThreadPool</strong> : 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，新添加的会被加入到任务队列中。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
</ul>
<ul>
<li><p><strong>CachedThreadPool</strong>: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
</li>
<li><p><strong>ScheduledThreadPool</strong>:一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</li>
<li><p><strong>SingleThreadExecutor</strong>: 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</li>
</ul>
<p>学习博客:</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ad1adea6fb9a028c67624e9">Java 之 volatile 详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72828483">深入理解Java并发之synchronized实现原理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/195ae7c77afe">java volatile关键字解惑</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/WuXuanKun/p/5827060.html">ThreadLocal用法和实现原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luoweifu/article/details/46595285">编程思想之多线程与多进程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2116fff869b6">深入理解并发/并行，阻塞/非阻塞，同步/异步</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/03/31/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E2%80%94%E2%80%94activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/31/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E2%80%94%E2%80%94activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">老生常谈——activity生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-31 21:56:45" itemprop="dateCreated datePublished" datetime="2018-03-31T21:56:45+08:00">2018-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="老生常谈——activity生命周期"><a href="#老生常谈——activity生命周期" class="headerlink" title="老生常谈——activity生命周期"></a>老生常谈——activity生命周期</h2><p>对于activity的七个声生命周期回调，总是被大家翻来覆去的说，甚至说的都有些厌烦了，这部分知识虽然基础但也很重要，谁都不想在面试的时候只说出个一知半解，下面的分析是对阅读《安卓开发艺术探索》第一章后的整理和思考。</p>
<h3 id="一、正常情况下的生命周期分析"><a href="#一、正常情况下的生命周期分析" class="headerlink" title="一、正常情况下的生命周期分析"></a>一、正常情况下的生命周期分析</h3><p>先来上一张大家都熟悉的流程图,来复习一遍活动的生命周期</p>
<p><img src="http://img.hellofhy.cn/18-3-31/73503926.jpg"></p>
<p>然后来简单说说这七个回调方法</p>
<ul>
<li><p><strong>onCreate</strong> : activity被创建时调用，一般在这个方法中进行活动的初始化工作，如设置布局文件、加载数据、绑定控件等。</p>
</li>
<li><p><strong>onStart</strong> : 经历该回调后，activity由不可见变为可见，但此时处于后台可见，还不能和用户进行交互。</p>
</li>
<li><p><strong>onResume</strong> : 已经可见的activity从后台来到前台,可以和用户进行交互。</p>
</li>
</ul>
<ul>
<li><strong>onPause</strong> : 当用户启动了新的activity,原来的activity不再处于前台,也无法和用户进行交互，并且紧接着就会调用<code>onStop()</code>方法，但如果用户这时立刻按返回键回到原activity，就会调用<code>onResume()</code>方法让活动重新回到前台。而且在官方文档中给出了说明，不允许在<code>onPause()</code>方法中执行耗时操作，因为这会影响到新activity的启动，具体原因我们在后面分析。</li>
</ul>
<ul>
<li><p><strong>onStop</strong> : 这个回调代表了activity由可见变为完全不可见，在这里可以进行一些稍微重量级的操作。需要注意的是，处于<code>onPause()</code>和<code>onStop()</code>回调后的activity优先级很低，当有优先级更高的应用需要内存时，该应用就会被杀死，那么当再次返回原activity的时候，会重新调用activity的<code>onCreate()</code>方法。</p>
</li>
<li><p><strong>onDestroy</strong> : 来到了这个回调，说明activity即将被销毁，应该将资源的回收和释放工作在该方法中执行。</p>
</li>
<li><p><strong>onRestart</strong> : 这个回调代表了activity由完全不可见重新变为可见的过程，当activity经历了<code>onStop()</code>回调变为完全不可见后，如果用户返回原activity，便会触发该回调，并且紧接着会触发<code>onStart()</code>来使活动重新可见。</p>
</li>
</ul>
<p>想必大家已经对这个过程非常熟悉了，下面我们通过一些实际的场景来更加深入的理解一下活动的启动流程。</p>
<h4 id="1、-由活动A启动活动B时，活动A的onPause-与活动B的onResume-哪一个先执行？"><a href="#1、-由活动A启动活动B时，活动A的onPause-与活动B的onResume-哪一个先执行？" class="headerlink" title="1、 由活动A启动活动B时，活动A的onPause()与活动B的onResume()哪一个先执行？"></a>1、 由活动A启动活动B时，活动A的<code>onPause()</code>与活动B的<code>onResume()</code>哪一个先执行？</h4><p>下面创建两个正常的活动<code>MainActivity</code>和<code>FirstActivity</code>,在<code>MainActivity</code>中设置按钮点击进入<code>FirstActivity</code>,看看会发生什么:</p>
<p><img src="http://img.hellofhy.cn/18-3-31/4680139.jpg"></p>
<p>可以看到，是旧的Activity先执行<code>onPause</code>,新活动才开始启动。下面点击返回按钮:</p>
<p><img src="http://img.hellofhy.cn/18-3-31/44951459.jpg"></p>
<p>点击返回后，同样是新Activity先执行<code>onPause</code>，旧的活动才开始重新启动，进行<code>onRestart-&gt;onStart-&gt;onResume</code>的流程，也就是说当发生活动切换时，是原活动先执行<code>onPause</code>，然后紧接着目标活动开始创建或重新启动。</p>
<h4 id="2、dialog是否会对生命周期产生影响"><a href="#2、dialog是否会对生命周期产生影响" class="headerlink" title="2、dialog是否会对生命周期产生影响"></a>2、dialog是否会对生命周期产生影响</h4><p>从定义上来说，如果一个活动不在前台，也并非完全不可见，这个活动就会处在<code>onPause()</code>的暂停状态，我们来模拟一下这种情况，在<code>MainActivity</code>中设置三个按钮，第一个按钮点击后会弹出一个标准的<code>AlertDialog</code>，第二个按钮会弹出一个全屏的<code>AlertDialog</code>,第三个按钮点击会出现一个主题为<code>Theme.AppCompat.Dialog</code>的activity然后观察生命周期的变化：</p>
<p><img src="http://img.hellofhy.cn/18-3-31/40345760.jpg"></p>
<p>首先可以看到，无论是正常的dialog还是全屏的dialog，活动依然维持在<code>onResume()</code>的状态，说明单纯的dialog并不会引起生命周期的变化。下面来看dialog主题的activity:</p>
<p><img src="http://img.hellofhy.cn/18-3-31/48233598.jpg"></p>
<p>在启动<code>DialogActivity</code>后，原来的活动进入<code>onPause()</code>，新活动正常进行<code>onCreate-&gt;onStart-&gt;onResume</code>的流程，而原来的活动因为并没有完全不可见，所以也没有执行<code>onStop</code>，事实上除了dialog主题的活动，一些透明主题的活动也能达到同样的效果，接下来我们点击返回按钮:</p>
<p><img src="http://img.hellofhy.cn/18-3-31/53627709.jpg"></p>
<p>由于<code>MainActivity</code>根本没有进入<code>onStop</code>的状态，所以返回时也不会进行<code>onRestart-&gt;onStart</code>的流程，而是直接<code>onResume</code>回到前台。</p>
<h3 id="二、异常状态下活动的生命周期"><a href="#二、异常状态下活动的生命周期" class="headerlink" title="二、异常状态下活动的生命周期"></a>二、异常状态下活动的生命周期</h3><p>当活动在运行过程中发生了某些异常情况时，上述所讨论的生命周期流程可能会受到影响，这里主要讨论两种异常情况。</p>
<h4 id="1、资源配置改变导致activity重建"><a href="#1、资源配置改变导致activity重建" class="headerlink" title="1、资源配置改变导致activity重建"></a>1、资源配置改变导致activity重建</h4><p>最常见的一种情况就是横竖屏的切换导致资源的变化，当程序启动时，会根据不同的配置加载不同的资源，例如横竖屏两个状态对应着两张不同的资源图片。如果在应用使用过程中屏幕突然旋转，那么activity就会因为系统配置发生改变而销毁重建，加载合适的资源。</p>
<h5 id="1-数据保存"><a href="#1-数据保存" class="headerlink" title="(1) 数据保存"></a>(1) 数据保存</h5><p>对于活动重新创建，我们如何保证activity中的已有数据不丢失呢，系统为我们提供了<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>来保存和获取数据。</p>
<pre><code>@Override
protected void onSaveInstanceState(Bundle outState) &#123;
    super.onSaveInstanceState(outState);
    Log.i(TAG, &quot;onSaveInstanceState: &quot;);
&#125;

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;
    super.onRestoreInstanceState(savedInstanceState);
    Log.i(TAG, &quot;onRestoreInstanceState: &quot;);
&#125;</code></pre>
<p><img src="http://img.hellofhy.cn/18-4-1/71262516.jpg"></p>
<p>在活动异常销毁之前，系统会调用<code>onSaveInstanceState</code>，我们可以在<code>Bundle</code>类型的参数中保存想要的信息，之后这个<code>Bundle</code>对象会作为参数传递给<code>onRestoreInstanceState</code>和<code>onCreat</code>方法，这样在重新创建时就可以获取数据了。关于这两个方法，有几点需要注意的地方：</p>
<ul>
<li><p><code>onSaveInstanceState</code>方法的调用时机是在<code>onStop</code>之前，与<code>onPause</code>没有固定的时序关系。而<code>onRestoreInstanceState</code>方法则是在<code>onStart</code>之后调用。</p>
</li>
<li><p>正常情况下的活动销毁并不会调用这两个方法，只有当活动异常销毁并且有机会重新展示的时候才会进行调用，除了资源配置的改变外，activity因内存不足被销毁也是通过这两个方法保存数据。</p>
</li>
<li><p>在<code>onRestoreInstanceState</code>和<code>onCreat</code>都可以进行数据恢复工作，但是根据官方文档建议采用在<code>onRestoreInstanceState</code>中去恢复。</p>
</li>
<li><p>在<code>onRestoreInstanceState</code>和<code>onRestoreInstanceState</code>这两个方法中，系统会默认为我们进行一定的恢复工作，例如<code>EditText</code>中的文本信息、<code>ListView</code>中的滚动位置等，下面对一些控件观察实际保存效果。</p>
<ul>
<li><p><code>EditText</code>:个人在对<code>EditText</code>实验的时候，发现转屏后文本信息并没有被保存，经过查询，发现了这样一句话：</p>
<blockquote>
<p>“Note: In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the android:id attribute.”<br>Android系统存储和还原View的状态必须有一个唯一的ID</p>
</blockquote>
<p>  果然加上id之后<code>EditText</code>中的信息可以被自动保存了。</p>
</li>
<li><p><code>TextView</code>:这里指的是通过<code>setText</code>方法动态设置文本内容，在这种情况下即使加了id也无法自动保存，这种情况可以通过给<code>TextView</code>设置<code>freezesText</code>属性才能自动保存，当然这条属性对<code>EditText</code>也同样适用。</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-防止重建"><a href="#2-防止重建" class="headerlink" title="(2) 防止重建"></a>(2) 防止重建</h5><p>我们已经知道默认情况下，资源配置改变会导致活动的重新创建，但我们可以通过对活动<code>android:configChanges</code>属性的设置使活动防止重新被创建，我们来看看这个属性中有哪些内容:</p>
<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mcc</td>
<td align="left">SIM卡唯一标识IMSI(国际移动用户标识码)中的国家代码，由三位数字组成，中国为：460 这里标识mcc代码发生了改变</td>
</tr>
<tr>
<td align="left">mnc</td>
<td align="left">SIM卡唯一标识IMSI(国际移动用户标识码)中的运营商代码，有两位数字组成，中国移动TD系统为00，中国联通为01,电信为03,此项标识mnc发生了改变</td>
</tr>
<tr>
<td align="left">locale</td>
<td align="left">设备的本地位置发生了改变，一般指的是切换了系统语言</td>
</tr>
<tr>
<td align="left">touchscreen</td>
<td align="left">触摸屏发生了改变</td>
</tr>
<tr>
<td align="left">keyboard</td>
<td align="left">键盘类型发生了改变，比如用户使用了外接键盘</td>
</tr>
<tr>
<td align="left">keyboardHidden</td>
<td align="left">键盘的可访问性发生了改变，比如用户调出了键盘</td>
</tr>
<tr>
<td align="left">navigation</td>
<td align="left">系统导航方式发生了改变</td>
</tr>
<tr>
<td align="left">screenLayout</td>
<td align="left">屏幕布局发生了改变，很可能是用户激活了另外一个显示设备</td>
</tr>
<tr>
<td align="left">fontScale</td>
<td align="left">系统字体缩放比例发生了改变，比如用户选择了个新的字号</td>
</tr>
<tr>
<td align="left">uiMode</td>
<td align="left">用户界面模式发生了改变，比如开启夜间模式-API8新添加</td>
</tr>
<tr>
<td align="left">orientation</td>
<td align="left">屏幕方向发生改变，比如旋转了手机屏幕</td>
</tr>
<tr>
<td align="left">screenSize</td>
<td align="left">当屏幕尺寸信息发生改变(当编译选项中的minSdkVersion和targeSdkVersion均低于13时不会导致Activity重启)API13新添加</td>
</tr>
<tr>
<td align="left">smallestScreenSize</td>
<td align="left">设备的物理屏幕尺寸发生改变，这个和屏幕方向没关系，比如切换到外部显示设备-API13新添加</td>
</tr>
<tr>
<td align="left">layoutDirection</td>
<td align="left">当布局方向发生改变的时候，正常情况下无法修改布局的layoutDirection的属性-API17新添加</td>
</tr>
</tbody></table>
<p>如果不希望某些资源配置改变时活动被重建，只需在<code>manifest</code>中为相应活动添加属性即可，例如           <code>configChanges=&quot;orientation&quot;</code>可以防止横竖屏引发的重启，然而事实上单加这条属性并没有什么效果，因为在api13之后，新添加的属性<code>screenSize</code>属性也会跟着设备的横竖切换而改变,所以正确的配置应该是<code>configChanges=&quot;orientation|screenSize&quot;</code>;而在api13之前，正确的配置应该是<code>configChanges=&quot;orientation|keyboardHidden&quot;</code></p>
<p>这里还要介绍一个重写方法<code>onConfigurationChanged</code>,用来监听资源配置的改变，这个方法只有在设置了<code>configChanges</code>并且相应的属性发生了变化时才会被调用，</p>
<pre><code>@Override
public void onConfigurationChanged(Configuration newConfig) &#123;
    super.onConfigurationChanged(newConfig);
    //监听横竖屏的变化
    Log.i(TAG, &quot;onConfigurationChanged: &quot;+newConfig.orientation);
&#125;</code></pre>
<h4 id="2、低优先级的activity由于内存不足被杀死"><a href="#2、低优先级的activity由于内存不足被杀死" class="headerlink" title="2、低优先级的activity由于内存不足被杀死"></a>2、低优先级的activity由于内存不足被杀死</h4><p>这种情况的数据保存方法和上一种情况相同，在这里简单说一下系统回收进程的优先级:</p>
<h5 id="1-前台进程："><a href="#1-前台进程：" class="headerlink" title="(1) 前台进程："></a>(1) 前台进程：</h5><ul>
<li>持有用户正在交互的activity，即生命周期处于<code>onResume</code>状态的活动。</li>
<li>该进程有绑定到正在交互的Activity的service或前台service。</li>
</ul>
<h5 id="2-可见进程"><a href="#2-可见进程" class="headerlink" title="(2) 可见进程:"></a>(2) 可见进程:</h5><p>这种进程虽然不在前台，但是仍然可见。</p>
<ul>
<li>该进程持有的Activity执行了<code>onPause</code>但未执行<code>onStop</code>。例如原活动启动了一个 dialog主题的activity，但此时原活动并非完全不可见。</li>
<li>该进程有service绑定到可见的或前台Activity。</li>
</ul>
<h5 id="3-服务进程："><a href="#3-服务进程：" class="headerlink" title="(3) 服务进程："></a>(3) 服务进程：</h5><p>进程中持有一个service，同时不属于上面两种情况。</p>
<h5 id="4-后台进程："><a href="#4-后台进程：" class="headerlink" title="(4) 后台进程："></a>(4) 后台进程：</h5><p>不属于上面三种情况，但进程持有一个不可见的<code>activity</code>,即执行了<code>onStop</code>但未执行<code>onDestroy</code>的状态。</p>
<h5 id="5-空进程"><a href="#5-空进程" class="headerlink" title="(5) 空进程:"></a>(5) 空进程:</h5><p>不包含任何活跃的应用组件，作用是加快下次启动这个进程中组件所需要的时间，优先级最低。</p>
<h2 id="activity的启动模式"><a href="#activity的启动模式" class="headerlink" title="activity的启动模式"></a>activity的启动模式</h2><p>和生命周期一样，activity的四种<code>launchMode</code>也非常重要但又特别容易混淆，首先，activity是以任务栈的形式创建和销毁的，栈是一种“后进先出”的数据结构，在默认情况下，启动第一个activity时，系统将会为它创建一个任务栈并将活动置于栈底，而从这个activity启动的其他activity将会依次入栈，当用户连续按下返回键时，任务栈中的activity会从栈顶开始依次销毁。但是这样有一个弊端，就是对于某些activity我们不希望它总是重新创建，这时就需要采用不同的启动模式，下面就简单复习下activity的四种启动模式 :</p>
<ul>
<li><strong>standard(标准模式)</strong> : 这是activity的默认启动模式，只要启动activity就会创建一个新实例，例如有两个活动ActivityA和AciivityB，现在从活动A中连续3次启动B活动，那么活动B就会依次创建三个实例，按顺序进入ActivityA所在的任务栈中。</li>
</ul>
<p><img src="http://img.hellofhy.cn/18-4-1/20324066.jpg"></p>
<p>执行<code>adb shell dumpsys activity</code>命令观察任务栈中的实际情况:</p>
<p><img src="http://img.hellofhy.cn/18-4-2/55270989.jpg"></p>
<ul>
<li><p><strong>singleTop(栈顶复用)</strong> :在这种启动模式下，首先会判断要启动的活动是否已经存在于栈顶，如果是的话就不创建新实例，直接复用栈顶活动。如果要启动的活动不位于栈顶或在栈中无实例，则会创建新实例入栈。例如栈中有活动A、B、C，启动模式全部为<code>singleTop</code>,现在想要新建一个活动C，执行完成后任务栈中的情况依然为A、B、C; 但是如果新建一个活动A，因为A不位于栈顶，所以会重新创建实例入栈，任务栈变为:A、B、C、A，</p>
<p>  <img src="http://img.hellofhy.cn/18-4-1/21672515.jpg"></p>
<p>  初始任务栈状态</p>
<p>  <img src="http://img.hellofhy.cn/18-4-2/56109014.jpg"></p>
<p>  接着启动活动A</p>
<p>  <img src="http://img.hellofhy.cn/18-4-2/66489532.jpg"></p>
<p>  可以看到活动A被重新创建入栈，但如果是启动活动C,栈内活动不会改变，只不过活动C会先经历<code>onPause</code>，然后回调<code>onNewIntent</code>方法，紧接着执行<code>onResume</code>。</p>
<p>  <img src="http://img.hellofhy.cn/18-4-2/33022579.jpg"></p>
</li>
</ul>
<ul>
<li><p><strong>singleTask(栈内复用)</strong> : 这种模式比较复杂，是一种栈内单例模式，当一个activity启动时，会进行两次判断</p>
<ul>
<li><p>首先会寻找是否有这个活动需要的任务栈，如果没有就创建这个任务栈并将活动入栈，如果有的话就进入下一步判断。</p>
</li>
<li><p>第二次判断这个栈中是否存在该activity的实例，如果不存在就新建activity入栈，如果存在的话就直接复用，并且带有<code>clearTop</code>效果，会将该实例上方的所有活动全部出栈，令这个activity位于栈顶。</p>
</li>
</ul>
<p>  <strong>场景一</strong>:假设当前任务栈中只有活动A，想要从A启动<code>launchMode</code>为<code>singleTask</code>的活动B，但是活动B指定的任务栈与A不同,这里用到了<code>TaskAffinity</code>属性，相当于指定了想要的任务栈，下面会详细介绍。</p>
<pre><code>  &lt;activity
      android:name=&quot;.test.ActivityA&quot;
      android:taskAffinity=&quot;com.example.a41061.task1&quot;&gt;
      &lt;intent-filter&gt;
          &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
          &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
      &lt;/intent-filter&gt;
  &lt;/activity&gt;

  &lt;activity
      android:name=&quot;.test.ActivityB&quot;
      android:launchMode=&quot;singleTask&quot;
      android:taskAffinity=&quot;com.example.a41061.task2&quot;/&gt;</code></pre>
<p>  启动后可以看到活动B运行在了一个新task中。</p>
<p>  <img src="http://img.hellofhy.cn/18-4-2/73842158.jpg">    </p>
<p>  <strong>场景二</strong>: 当前任务栈task1中存在活动A，从A中连续启动三个活动，顺序为B-&gt;C-&gt;B，B、C的启动模式均为<code>singleTask</code>，请求栈为task2，最后的启动结果将和上一种场景一样，不再重复展示，这里体现了<code>singleTask</code>模式的<code>clearTop</code>属性，第二次启动activityB后会复用栈底的实例，并将activityC出栈。</p>
</li>
</ul>
<ul>
<li><strong>singleInstance(单例)</strong> : 这种模式是真正的单例模式，以这种模式启动的活动会单独创建一个任务栈，并且依然遵循栈内复用的特性，保证了这个栈中只能存在这一个活动。</li>
</ul>
<p>还有一些需要注意的属性</p>
<ul>
<li><p>**onNewIntent()**方法 : 后三种模式都会出现活动复用的情况，一旦活动被复用，就会回调用<code>onNewIntent</code>方法,通过这个方法中的Intent参数就可以进行页面的更新，举一个实际应用场景的例子:</p>
<ul>
<li>在活动A点击设置密码按钮进入活动B: <code>A-&gt;B</code></li>
<li>在活动B中设置密码后点击完成后进入活动C: <code>A-&gt;B-&gt;C</code></li>
<li>在活动C中点击确认，返回活动A，并且携带已经确认的信息: <code>A-&gt;B-&gt;C-&gt;A</code></li>
<li>活动A在<code>onNewIntent</code>方法中获取信息，将设置密码字样改为修改密码。</li>
</ul>
</li>
<li><p><strong>TaskAffinity属性</strong> : 这个属性代表活动的亲和性，即一个活动启动时想要指定的任务栈名字，在默认情况下，所有活动所需的任务栈名字为所应用的包名。</p>
</li>
</ul>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lygsust/article/details/52777537">Android系统回收Activity的优先级</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33544860/article/details/54863895">Android configChanges的属性值和含义</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/03/23/Mac+django+nginx+uwsgi+mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fhyPayaso">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fhyPayaso's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/Mac+django+nginx+uwsgi+mysql/" class="post-title-link" itemprop="url">Linux+django+nginx+uwsgi+mysql部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-03-23T00:00:00+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 16:29:27" itemprop="dateModified" datetime="2020-12-29T16:29:27+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index"><span itemprop="name">Django</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-django-nginx-uwsgi-mysql部署"><a href="#Linux-django-nginx-uwsgi-mysql部署" class="headerlink" title="Linux+django+nginx+uwsgi+mysql部署"></a>Linux+django+nginx+uwsgi+mysql部署</h1><h2 id="1-mac终端登录服务器ubuntu系统"><a href="#1-mac终端登录服务器ubuntu系统" class="headerlink" title="1.mac终端登录服务器ubuntu系统"></a>1.mac终端登录服务器ubuntu系统</h2><h4 id="通过ssh连接"><a href="#通过ssh连接" class="headerlink" title="通过ssh连接"></a>通过ssh连接</h4><ul>
<li>创建秘钥并下载</li>
<li>将ssh绑定到云主机(服务器需要关机)</li>
<li>将下载的ssh放入.ssh文件中</li>
<li>连接操作：</li>
</ul>
<pre><code>    ssh ubuntu@123.206.21.17</code></pre>
<p>出现了</p>
<pre><code>Permission denied (publickey).</code></pre>
<p>这是由于没有将公钥<code>( publickey )</code>  添加到本地 ssh 环境造成的，或者是由于多日未 进行<code>ssh</code> 登录操作，本地 <code>publickey</code> 失效造成的。添加一下即可。</p>
<pre><code>ssh-add ~/.ssh/ubuntu</code></pre>
<p>再次登录即可成功。</p>
<h2 id="2-装python环境"><a href="#2-装python环境" class="headerlink" title="2. 装python环境"></a>2. 装python环境</h2><ul>
<li><h4 id="更新软件列表和本地软件"><a href="#更新软件列表和本地软件" class="headerlink" title="更新软件列表和本地软件"></a>更新软件列表和本地软件</h4><pre><code>  sudo apt-get update //列表
  sudo apt-get upgrade //本地</code></pre>
</li>
</ul>
<ul>
<li><h4 id="安装多版本python"><a href="#安装多版本python" class="headerlink" title="安装多版本python"></a>安装多版本python</h4><ul>
<li><p>ubuntu自带python2.7版本</p>
<pre><code>  python --version</code></pre>
</li>
<li><p>安装python3</p>
<pre><code>  sudo apt-get install python3</code></pre>
</li>
<li><p>为python安装pip3</p>
<pre><code>  sudo apt install python3-pip</code></pre>
</li>
<li><p>更新一下pip版本</p>
<pre><code>  pip3 install --upgrade pip</code></pre>
<p>  但是这样操作你会发现pip3并没升级，还是8.1.1版本</p>
</li>
<li><p>用管理员权限更新即可</p>
<pre><code>  sudo -H pip3 install --upgrade pip</code></pre>
</li>
<li><p>查看当前pip3版本，应该是升级到9.0了</p>
<pre><code>  pip3 --version</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-配置虚拟环境"><a href="#3-配置虚拟环境" class="headerlink" title="3.配置虚拟环境"></a>3.配置虚拟环境</h2><ul>
<li><h4 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h4><pre><code>  sudo pip3 install virtualenv</code></pre>
<p>  <code>virtualenv</code>是虚拟环境安装包，创建虚拟环境可以更好地控制包的版本，包的版本不会因为2.1中的升级操作而升级，保证了项目的稳定性，不同虚拟环境之间的运行环境相互独立，互不干扰。</p>
</li>
<li><h4 id="管理我们的虚拟环境"><a href="#管理我们的虚拟环境" class="headerlink" title="管理我们的虚拟环境"></a>管理我们的虚拟环境</h4><pre><code>  sudo pip install virtualenvwrapper</code></pre>
<p>  <code>virtualenvwrapper</code>是<code>virtualenv</code>的扩展管理包，可以将所有的虚拟环境整合在一个目录下，使用前需要先进行以下配置</p>
<ul>
<li><p>创建虚拟环境管理目录</p>
<pre><code>  mkdir ~/.virtualenvs</code></pre>
</li>
<li><p>打开.bashrc</p>
<pre><code>  sudo vi ~/.bashrc</code></pre>
</li>
<li><p>在末尾添加以下内容</p>
<pre><code>  export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 # 这句是为了防止环境变量$PATH中已有其它环境的python
  export WORKON_HOME=$HOME/.virtualenvs    # 放所有虚拟环境的地方
  source /usr/local/bin/virtualenvwrapper.sh</code></pre>
</li>
<li><p>启用配置文件</p>
<pre><code>  source ~/.bashrc</code></pre>
<p>  这里有个小坑，服务器长时间不操作会中断连接，报错</p>
<pre><code>  packet_write_wait: Connection to 123.206.21.17 port 22: Broken pipe</code></pre>
<p>  重新登录即可。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h4><pre><code>  mkvirtualenv env_mysite</code></pre>
<p>  创建虚拟环境需要联网,创建完虚拟环境之后会自动进入虚拟环境，可以通过命令行前括号判断是否在虚拟环境内。</p>
<p>  <img src="http://img.hellofhy.cn/18-3-23/61204845.jpg"></p>
<p>  常用操作</p>
<pre><code>  # 创建虚拟环境
  mkvirtualenv &lt;name&gt;
  # 列出所有虚拟环境
  workon TAB*2
  # 进入虚拟环境
  workon &lt;name&gt;
  # 退出虚拟环境
  deactivate
  # 删除虚拟环境
  rmvirtualenv &lt;name&gt;</code></pre>
</li>
<li><p>在虚拟环境中安装django包</p>
<pre><code>  pip install django</code></pre>
</li>
</ul>
<ul>
<li><p>这里安装一个tree包，可以清楚的看见文件接结构</p>
<pre><code>  sudo apt-get install tree</code></pre>
<p>  常用方法</p>
<pre><code>  # 查看当前目录下所有文件结构
  tree 
  # 只查看当前第一级的目录和文件
  tree -L 1</code></pre>
</li>
</ul>
<h2 id="4-用PyCharm将项目上传到服务器（本地）"><a href="#4-用PyCharm将项目上传到服务器（本地）" class="headerlink" title="4.用PyCharm将项目上传到服务器（本地）"></a>4.用PyCharm将项目上传到服务器（本地）</h2><ul>
<li><p>导出本机虚拟环境中的包</p>
<pre><code>  sudo pip freeze &gt; plist.txt</code></pre>
</li>
<li><p>利用PyCharm将代码上传到服务器</p>
</li>
</ul>
<p><img src="http://img.hellofhy.cn/18-3-23/44651550.jpg"><br>配置好连接域名和ssh</p>
<p><img src="http://img.hellofhy.cn18-3-23/28161423.jpg"><br>点击测试连接，如果没问题会有成功提示</p>
<p><img src="http://img.hellofhy.cn/18-3-23/85092329.jpg"><br>配置你本地上传路径和服务器上项目的路径</p>
<p><img src="http://img.hellofhy.cn/18-3-23/59100245.jpg"><br>选择你要上传的部分，右键上传即可</p>
<p><img src="http://img.hellofhy.cn/18-3-23/55882304.jpg"><br>再连接你的服务器，就会发现代码已经上传成功了。然后进入虚拟环境，进入项目目录，将之前导出的包安装。</p>
<pre><code>    pip install -r plist.txt</code></pre>
<ul>
<li><p>配置项目<code>settings.py    </code>，修改以下一项</p>
<pre><code>  ALLOWED_HOSTS = [&#39;*&#39;, ]</code></pre>
</li>
<li><p>在项目根目录文件夹下，在终端内（确保已进入虚拟环境）</p>
<pre><code>  python manage.py runserver 0:8000</code></pre>
<p>  访问8000端口检查django在服务器上是否能运行,成功说明django项目正常</p>
</li>
</ul>
<h2 id="5-uWSGI安装及配置"><a href="#5-uWSGI安装及配置" class="headerlink" title="5.uWSGI安装及配置"></a>5.uWSGI安装及配置</h2><ul>
<li><p>安装Python开发版本（因为安装uWSGI过程中需要编译）</p>
<pre><code>  sudo apt-get install python-dev</code></pre>
</li>
<li><p>安装gcc（因为安装uWSGI过程中需要C编译器）</p>
<pre><code>  sudo apt-get install gcc</code></pre>
</li>
<li><p>安装uWSGI</p>
<pre><code>  sudo pip install uwsgi</code></pre>
<p>  使用<code>uwsgi --version</code>命令查看版本号，确认已正确安装</p>
</li>
</ul>
<h2 id="6-配置uWSGI"><a href="#6-配置uWSGI" class="headerlink" title="6.配置uWSGI"></a>6.配置uWSGI</h2><ul>
<li><h4 id="打通uWSGI和Python"><a href="#打通uWSGI和Python" class="headerlink" title="打通uWSGI和Python"></a>打通uWSGI和Python</h4><ul>
<li><p>在项目根目录创建test.py文件，内容如下</p>
<pre><code>  def application(env, start_response):
  start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)])
  return [b&quot;Hello World&quot;]  # python3</code></pre>
</li>
<li><p>运行uWSGI（表示使用http协议，并使用8000端口，加载指定文件test.py）</p>
<pre><code>  uwsgi --http :8000 --wsgi-file test.py</code></pre>
</li>
<li><p>访问8000端口，若显示’Hello World’则表示运行正常，说明以下三个环节是相通的</p>
<pre><code>  web client &lt;-&gt; uWSGI &lt;-&gt; Python</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="打通uWSGI和Django"><a href="#打通uWSGI和Django" class="headerlink" title="打通uWSGI和Django"></a>打通uWSGI和Django</h4><ul>
<li><p>在项目根目录创建文件uwsgi.ini，并写入以下内容</p>
<pre><code>  [uwsgi]
  # 使用nginx连接时使用
  # socket = 0:8001
  # 直接做web服务器使用
  http = 0:8080
  # 项目目录
  chdir = /home/ubuntu/projectname
  # 项目中wsgi.py文件的目录
  wsgi-file = /home/ubuntu/projectname/projectname/wsgi.py
  # 主进程
  master = true
  # 多进程&amp;多线程
  processes = 6
  threads = 2
  # .sock文件目录需与Nginx文件内的配置相同
  # socket = /home/python/Desktop/project_test/my_sock.sock
  # chmod-socket = 666
  # 以守护进程的方式启动
  vacuum = true
  # 存储pid进程
  pidfile=uwsgi.pid
  # 存储log日志
  daemonize=uwsgi.logv</code></pre>
</li>
<li><p>启动uWSGI服务</p>
<pre><code>  uwsgi --ini uwsgi.ini</code></pre>
</li>
<li><p>终端显示以下内容即代表开启成功</p>
<pre><code>  [uWSGI] getting INI configuration from my_uwsgi.ini</code></pre>
</li>
</ul>
</li>
</ul>
<pre><code>+ 访问8000端口，发现文字可以显示，图片不能显示，这是正常现象

    ![](http://img.hellofhy.cn/18-3-24/88907634.jpg)

+ 以上步骤说明以下三个环节是相通的

        web client &lt;-&gt; uWSGI &lt;-&gt; Django

+ 停止uWSGI服务

        uwsgi --stop uwsgi.pid</code></pre>
<h2 id="7-配置nginx"><a href="#7-配置nginx" class="headerlink" title="7.配置nginx"></a>7.配置nginx</h2><ul>
<li><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>  sudo apt-get install nginx</code></pre>
<p>  Nginx安装成功后，系统会自动开启 Nginx 服务，默认使用80端口，打开浏览器并输入你服务器的IP地址，就可以看到 nginx 的测试页面.</p>
<p>  <img src="http://img.hellofhy.cn/18-3-24/57137138.jpg"></p>
<p>  说明以下两个环节是相通的</p>
<pre><code>  web client &lt;-&gt; the web server（Nginx）</code></pre>
</li>
</ul>
<ul>
<li><h4 id="配置ngxin"><a href="#配置ngxin" class="headerlink" title="配置ngxin"></a>配置ngxin</h4><ul>
<li><p>将<code>/etc/nginx/</code>目录下的<code>uwsgi_params</code>复制到项目文件夹，对此文件不做任何改动</p>
<pre><code>  cp /etc/nginx/uwsgi_params .</code></pre>
</li>
<li><p>在项目根目录创建文件<code>my_nginx.conf</code>，并写入以下内容</p>
<pre><code>  upstream django &#123;
  server    127.0.0.1:8001;
  # server      unix://home/python/Desktop/project_test/my_sock.sock;
  &#125;
  server &#123;
      listen      8000;  # 端口号
      server_name 127.0.0.1;  # 服务器 ip 或是域名(具体)
      charset     utf-8;  # 字符集
      # 最大上传限制
      # client_max_body_size 75M;
      location /media  &#123;
          alias /home/ubuntu/mysite/media_common;  # 媒体文件所在文件夹
      &#125;
      location /static &#123;
          alias /home/ubuntu/mysite/static_common;  # 静态文件所在文件夹
      &#125;
      # 将所有非媒体请求转到Django服务器上
      location / &#123;
          uwsgi_pass      django;  # 最上方已定义
          # 将所有参数都转到uwsgi下
          include         /home/ubuntu/mysite/uwsgi_params; # uwsgi_params的路径
      &#125;
  &#125;</code></pre>
<p>  这个配置文件表示将静态文件和媒体文件由Nginx处理，而其它的请求转入uWSGI处理</p>
</li>
</ul>
</li>
</ul>
<pre><code>+ 与Nginx配置目录建立软链接
    sudo ln -s /home/ubuntu/mysite/my_nginx.conf /etc/nginx/sites-enabled/

+ 这里注意把nginx的默认配置删掉
    rm /etc/nginx/sites-enabled/sites-available/defult

+ 创建静态文件与媒体文件存放目录
    sudo mkdir static_common
    sudo mkdir media_common

+ 如果出现权限问题，将权限改下就好
    chmod 777 static_common
    chmod 777 media_common

+ 修改项目`setting.py`,在最后添加
    STATIC_ROOT = os.path.join(BASE_DIR, &#39;static_common&#39;)
    MEDIA_ROOT = os.path.join(BASE_DIR, &#39;media_common&#39;)

+ 进入项目根目录，执行静态文件迁移命令
    python3 manage.py collectstatic</code></pre>
<h2 id="8-Nginx-uWSGI-Django"><a href="#8-Nginx-uWSGI-Django" class="headerlink" title="8.Nginx+uWSGI+Django"></a>8.Nginx+uWSGI+Django</h2><ul>
<li><h4 id="测试Nginx"><a href="#测试Nginx" class="headerlink" title="测试Nginx"></a>测试<code>Nginx</code></h4><ul>
<li><p>重启nginx服务</p>
<pre><code>  sudo /etc/init.d/nginx restart</code></pre>
</li>
<li><p>在浏览器内输入<code>&lt;YOUR_SERVER_IP&gt;:8000/static/admin/css/base.css</code>，检查是否能正常显示这个css文件</p>
<p><img src="http://p0y1qzu73.bkt.clouddn.com/18-3-24/47870898.jpg"></p>
</li>
<li><p>将一张测试图片<code>test.jpg</code>放入<code>media_common</code>文件夹中，在浏览器中输入<code>&lt;YOUR_SERVER_IP&gt;:8000/media/test.jpg</code>，如果出现403则将图片的权限改为666，成功显示图片</p>
<p><img src="http://p0y1qzu73.bkt.clouddn.com/18-3-24/63838589.jpg"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="测试uWSGI"><a href="#测试uWSGI" class="headerlink" title="测试uWSGI"></a>测试uWSGI</h4><p>  在根目录运行之前的<code>test.py</code>,如果访问<code>&lt;YOUR_SERVBER_IP&gt;</code>显示hello world,说明uWSGI正常</p>
<pre><code>  uwsgi --socket :8001 --wsgi-file test.py</code></pre>
</li>
<li><h4 id="用UNIX-socket取代TCP-port"><a href="#用UNIX-socket取代TCP-port" class="headerlink" title="用UNIX socket取代TCP port"></a>用<code>UNIX socket</code>取代<code>TCP port</code></h4></li>
</ul>
<pre><code>+ 修改`my_nginx.conf`，最终版如下：


        upstream django &#123;
        # server    127.0.0.1:8001;
        server      unix://home/ubuntu/mysite/my_sock.sock;
        &#125;

        server &#123;
            listen      8000;  # 端口号
            server_name 127.0.0.1;  # 服务器 ip 或是域名(具体)
            charset     utf-8;  # 字符集
            # 最大上传限制
            # client_max_body_size 75M;
            location /media  &#123;
                alias /home/ubuntu/mysite/media_common;  # 媒体文件所在文件夹
            &#125;
            location /static &#123;
                alias /home/ubuntu/mysite/static_common;  # 静态文件所在文件夹
            &#125;
            # 将所有非媒体请求转到Django服务器上
            location / &#123;
                uwsgi_pass      django;  # 最上方已定义
                # 将所有参数都转到uwsgi下
                include         /home/ubuntu/mysite/uwsgi_params; # uwsgi_params的路径
            &#125;
        &#125;


+ 修改`my_uwsgi.ini`，最终版如下

        [uwsgi]
        # 使用nginx连接时使用
        # socket = 0:8001
        # 直接做web服务器使用
        # http = 0:8080
        # 项目目录
        chdir = /home/ubuntu/projectname
        # 项目中wsgi.py文件的目录
        wsgi-file = /home/ubuntu/projectname/projectname/wsgi.py
        # 主进程
        master = true
        # 多进程&amp;多线程
        processes = 6
        threads = 2
        # .sock文件目录需与Nginx文件内的配置相同
        socket = /home/home/ubuntu/mysite/my_sock.sock
        chmod-socket = 666
        # 以守护进程的方式启动
        vacuum = true
        # 存储pid进程
        pidfile=uwsgi.pid
        # 存储log日志
        daemonize=uwsgi.logv


+ 重启Nginx和uWSGI

        sudo /etc/init.d/nginx restart
        uwsgi --stop uwsgi.pid
        uwsgi --ini my_uwsgi.ini

+ 打开浏览器，地址栏输入网址`&lt;YOUR_SERVER_IP&gt;:8000`，查看图片和文字是否显示正常



+ 此时以下环节已全部打通

        web client &lt;-&gt; web server(nginx) &lt;-&gt; the socket &lt;-&gt; uwsgi &lt;-&gt; Django

+ 服务器开机自启

    修改`/etc/rc.local`，添加以下内容到`exit 0`之前

        /usr/local/bin/uwsgi --ini /home/ubuntu/uwsgi.ini</code></pre>
<h2 id="9-配置MySql"><a href="#9-配置MySql" class="headerlink" title="9.配置MySql"></a>9.配置MySql</h2><ul>
<li><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>安装mysql，安装过程中会让你设置密码</p>
<pre><code>  sudo apt-get install mysql-server    </code></pre>
</li>
<li><p>进入mysql</p>
<pre><code>  mysql -u root -p</code></pre>
</li>
</ul>
</li>
</ul>
<pre><code>    出现下图说明进入成功

    ![](http://img.hellofhy.cn/18-3-24/3056630.jpg)

+ 展示数据库内容

        show database;

    ![](http://img.hellofhy.cn/18-3-24/69529505.jpg)</code></pre>
<ul>
<li><h4 id="配置mysql能被远程访问"><a href="#配置mysql能被远程访问" class="headerlink" title="配置mysql能被远程访问"></a>配置mysql能被远程访问</h4></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>新建文件</p>
<pre><code>  vim test.py</code></pre>
</li>
</ul>
<ul>
<li><p>当前路径下新建文件夹</p>
<pre><code>  mkdir &lt;文件夹名&gt;</code></pre>
</li>
<li><p>解压zip</p>
<pre><code>  sudo unzip FileName.zip</code></pre>
</li>
<li><p>删除文件</p>
<pre><code>  rm &lt;文件夹名&gt;</code></pre>
</li>
<li><p>重命名文件</p>
<pre><code>  mv oldname newname</code></pre>
</li>
<li><p>vim常用操作</p>
<pre><code>  dd # 删除一行
  u # 版本回退</code></pre>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">fhyPayaso</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fhyPayaso</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
